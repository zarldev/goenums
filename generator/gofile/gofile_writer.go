package gofile

import (
	"context"
	"errors"
	"fmt"
	"io"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/zarldev/goenums/enum"
	"github.com/zarldev/goenums/file"
	"github.com/zarldev/goenums/generator/config"
)

var _ enum.Writer = &Writer{}

var (
	// ErrInvalidOutputFilename is returned when the output filename is invalid.
	ErrInvalidOutputFilename = errors.New("invalid output filename")
	// ErrWriteGoFile is returned when an error occurs while writing the go file.
	ErrWriteGoFile = errors.New("error writing go file")
)

type Writer struct {
	Configuration config.Configuration
	w             io.Writer
}

func NewWriter(cfg config.Configuration) *Writer {
	return &Writer{
		Configuration: cfg,
	}
}

// Write implements enum.RepresentationWriter.
func (g *Writer) Write(ctx context.Context,
	enums []enum.Representation) error {
	for _, enumRep := range enums {
		dirPath := filepath.Dir(enumRep.SourceFilename)
		outFilename := enumRep.TypeInfo.Lower + "_enums.go"
		if strings.Contains(outFilename, " ") || strings.Contains(outFilename, "/") {
			return fmt.Errorf("%w: %s", ErrInvalidOutputFilename, outFilename)
		}
		fullPath := filepath.Join(dirPath, outFilename)
		err := file.WriteToFileAndFormat(ctx, fullPath, true,
			func(w io.Writer) error {
				g.w = w
				g.writeEnumFile(enumRep)
				return nil
			})
		if err != nil {
			return fmt.Errorf("%w: %s: %w", ErrWriteGoFile, fullPath, err)
		}
	}
	return nil
}

func (g *Writer) writeEnumFile(enum enum.Representation) {
	// Top-level file structure
	g.writeGeneratedComment(enum)
	g.writePackage(enum)
	g.writeImports(enum)

	// Type definitions
	g.writeWrapperType(enum)
	g.writeInvalidTypeDefinition(enum)

	// Methods and functions
	g.writeAllMethod(enum)
	g.writeParsingMethods(enum)
	g.writeExhaustiveMethod(enum)
	g.writeIsValidMethod(enum)

	// Database and JSON handling
	g.writeJSONMarshalMethod(enum)
	g.writeJSONUnmarshalMethod(enum)
	g.writeScanMethod(enum)
	g.writeValueMethod(enum)

	// Other utility code
	g.writeCompileCheck(enum)
	g.writeStringMethod(enum)
}

// write writes a string to the output writer
// it is a wrapper around the io.Writer interface
func (g *Writer) write(s string) {
	_, _ = g.w.Write([]byte(s))
}

func (g *Writer) writeGeneratedComment(rep enum.Representation) {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("// Code generated by goenums %s at %s. DO NOT EDIT.\n",
		rep.Version, time.Now().Format(time.RFC3339)))
	b.WriteString("// This file was generated by github.com/zarldev/goenums \n")
	b.WriteString("// using the command:\n")
	b.WriteString("// goenums ")
	if rep.Failfast {
		b.WriteString("-f ")
	}
	if rep.Legacy {
		b.WriteString("-l ")
	}
	if rep.CaseInsensitive {
		b.WriteString("-i ")
	}
	b.WriteString(rep.SourceFilename + "\n")
	b.WriteString("\n")
	g.write(b.String())
}

func (g *Writer) writePackage(rep enum.Representation) {
	g.write("package " + rep.PackageName + "\n\n")
}

// New combined function for all parsing methods
func (g *Writer) writeParsingMethods(enum enum.Representation) {
	// 1. First write the main Parse function
	g.writeParseFunction(enum)

	// 2. Then write the helper parsing methods
	g.writeStringParsingMethod(enum)
	g.writeIntParsingMethod(enum)
}

func (g *Writer) writeParseFunction(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("func Parse" + rep.TypeInfo.Camel + "(a any) (" + rep.TypeInfo.Camel + ", error) {\n")
	b.WriteString("\tres := invalid" + rep.TypeInfo.Camel + "\n")
	b.WriteString("\tswitch v := a.(type) {\n")
	b.WriteString("\tcase " + rep.TypeInfo.Camel + ":\n")
	b.WriteString("\t\treturn v, nil\n")
	b.WriteString("\tcase []byte:\n")
	b.WriteString("\t\tres = stringTo" + rep.TypeInfo.Camel + "(string(v))\n")
	b.WriteString("\tcase string:\n")
	b.WriteString("\t\tres = stringTo" + rep.TypeInfo.Camel + "(v)\n")
	b.WriteString("\tcase fmt.Stringer:\n")
	b.WriteString("\t\tres = stringTo" + rep.TypeInfo.Camel + "(v.String())\n")
	b.WriteString("\tcase int:\n")
	b.WriteString("\t\tres = intTo" + rep.TypeInfo.Camel + "(v)\n")
	b.WriteString("\tcase int64:\n")
	b.WriteString("\t\tres = intTo" + rep.TypeInfo.Camel + "(int(v))\n")
	b.WriteString("\tcase int32:\n")
	b.WriteString("\t\tres = intTo" + rep.TypeInfo.Camel + "(int(v))\n")
	b.WriteString("\t}\n")
	if rep.Failfast {
		b.WriteString("\tif res == invalid" + rep.TypeInfo.Camel + " {\n")
		errorMsg := fmt.Sprintf("failed to parse %s value - invalid input: %%v", rep.TypeInfo.Camel)
		b.WriteString("\t\treturn res, fmt.Errorf(\"" + errorMsg + "\", a)\n")
		b.WriteString("\t}\n")
	}
	b.WriteString("\treturn res, nil\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

// Change from setupStringToTypeMethod to writeStringParsingMethod
func (g *Writer) writeStringParsingMethod(rep enum.Representation) {
	var b strings.Builder
	// Generate a single lookup map with both original and lowercase entries if needed
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\t_%sNameMap = map[string]%s{\n", rep.TypeInfo.Lower, rep.TypeInfo.Camel))

	seen := make(map[string]bool)

	for _, info := range rep.Enums {
		original := info.Info.Alias
		lowercase := strings.ToLower(original)

		// Add original entry
		b.WriteString(fmt.Sprintf("\t\t%q: %s.%s,\n",
			original, rep.TypeInfo.PluralCamel, info.Info.Upper))

		// Add lowercase entry if case-insensitive and not a duplicate
		if rep.CaseInsensitive && lowercase != original && !seen[lowercase] {
			b.WriteString(fmt.Sprintf("\t\t%q: %s.%s,\n",
				lowercase, rep.TypeInfo.PluralCamel, info.Info.Upper))
			seen[lowercase] = true
		}
	}

	b.WriteString("\t}\n")
	b.WriteString(")\n\n")
	b.WriteString("func stringTo" + rep.TypeInfo.Camel + "(s string) " + rep.TypeInfo.Camel + " {\n")

	// Direct lookup
	b.WriteString(fmt.Sprintf("\tif v, ok := _%sNameMap[s]; ok {\n", rep.TypeInfo.Lower))
	b.WriteString("\t\treturn v\n")
	b.WriteString("\t}\n")

	// Only do lowercase conversion if case insensitive and direct lookup failed
	if rep.CaseInsensitive {
		b.WriteString("\tlwr := strings.ToLower(s)\n")
		b.WriteString("\tif lwr != s {\n")
		b.WriteString(fmt.Sprintf("\t\tif v, ok := _%sNameMap[lwr]; ok {\n", rep.TypeInfo.Lower))
		b.WriteString("\t\t\treturn v\n")
		b.WriteString("\t\t}\n")
		b.WriteString("\t}\n")
	}
	b.WriteString("\treturn invalid" + rep.TypeInfo.Camel + "\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

// Change from setupIntToTypeMethod to writeIntParsingMethod
func (g *Writer) writeIntParsingMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("func intTo" + rep.TypeInfo.Camel + "(i int) " + rep.TypeInfo.Camel + " {\n")
	if rep.TypeInfo.Index != 0 {
		b.WriteString("\ti = i - " + strconv.Itoa(rep.TypeInfo.Index) + "\n")
	}
	b.WriteString("\tif i < 0 || i >= len(" + rep.TypeInfo.PluralCamel + ".allSlice()) {\n")
	b.WriteString("\t\treturn invalid" + rep.TypeInfo.Camel + "\n")
	b.WriteString("\t}\n")
	b.WriteString("\treturn " + rep.TypeInfo.PluralCamel + ".allSlice()[i]\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

func (g *Writer) writeScanMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("func (p *" + rep.TypeInfo.Camel + ") Scan(value any) error {\n")
	b.WriteString("\tnewp, err := Parse" + rep.TypeInfo.Camel + "(value)\n")
	b.WriteString("\tif err != nil {\n")
	b.WriteString("\t\treturn err\n")
	b.WriteString("\t}\n")
	b.WriteString("\t*p = newp\n")
	b.WriteString("\treturn nil\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

func (g *Writer) writeValueMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("func (p " + rep.TypeInfo.Camel + ") Value() (driver.Value, error) {\n")
	b.WriteString("\treturn p.String(), nil\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}
func (g *Writer) generateIndexAndNameRun(rep enum.Representation) (string, string) {
	// Build the name string
	var namesBuilder strings.Builder
	positions := make([]int, 0, len(rep.Enums)+rep.TypeInfo.Index+1)

	// Start with position 0
	positions = append(positions, 0)

	// Add empty strings for any offset positions
	for i := range rep.TypeInfo.Index {
		positions = append(positions, positions[i]) // Use the same position as the previous index
	}

	// Add the actual enum names and record their positions
	for _, enum := range rep.Enums {
		namesBuilder.WriteString(enum.Info.Alias)
		positions = append(positions, namesBuilder.Len())
	}

	// Create the name constant
	nameStr := namesBuilder.String()
	nameConst := fmt.Sprintf("_%s_name = %q\n", rep.TypeInfo.Lower, nameStr)

	// Create the index array as a comma-separated list of constants
	var indexBuilder strings.Builder
	indexBuilder.WriteString(fmt.Sprintf("_%s_index = [...]uint16{", rep.TypeInfo.Lower))

	for i, pos := range positions {
		if i > 0 {
			indexBuilder.WriteString(", ")
		}
		indexBuilder.WriteString(fmt.Sprintf("%d", pos))
	}

	indexBuilder.WriteString("}\n")

	return indexBuilder.String(), nameConst
}

func (g *Writer) writeStringMethod(rep enum.Representation) {
	// Generate constants and indices

	indexVar, nameConst := g.generateIndexAndNameRun(rep)
	var b strings.Builder
	b.WriteString("const " + nameConst)
	b.WriteString("var " + indexVar)

	b.WriteString("func (i " + rep.TypeInfo.Name + ") String() string {\n")

	// Account for the index offset in bounds checking
	b.WriteString(fmt.Sprintf("\tif i < %d || i >= %s(len(_%s_index)-1) {\n",
		rep.TypeInfo.Index, rep.TypeInfo.Name, rep.TypeInfo.Lower))
	b.WriteString("\t\treturn \"" + rep.TypeInfo.Lower + "(\" + (strconv.FormatInt(int64(i), 10) + \")\")\n")
	b.WriteString("\t}\n")

	// Use the correct index with the offset
	b.WriteString(fmt.Sprintf("\treturn _%s_name[_%s_index[i]:_%s_index[i+1]]\n",
		rep.TypeInfo.Lower, rep.TypeInfo.Lower, rep.TypeInfo.Lower))
	b.WriteString("}\n")
	g.write(b.String())
}

func (g *Writer) writeCompileCheck(rep enum.Representation) {
	var b strings.Builder
	// Generate code that will fail if the constants change value.
	b.WriteString("func _() {\n")
	b.WriteString("\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n")
	b.WriteString("\t// Re-run the goenums command to generate them again.\n")
	b.WriteString("\t// Does not identify newly added constant values unless order changes\n")
	b.WriteString("\tvar x [1]struct{}\n")
	for _, v := range rep.Enums {
		b.WriteString(fmt.Sprintf("\t_ = x[%s - %d]\n", v.Info.Name, v.Info.Value+rep.TypeInfo.Index))
	}
	b.WriteString("}\n")
	g.write(b.String())
}

func (g *Writer) writeJSONMarshalMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("func (p " + rep.TypeInfo.Camel + ") MarshalJSON() ([]byte, error) {\n")
	b.WriteString("\treturn []byte(`\"`+p.String() + `\"`), nil\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

func (g *Writer) writeJSONUnmarshalMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("func (p *" + rep.TypeInfo.Camel + ") UnmarshalJSON(b []byte) error {\n")
	b.WriteString("b = bytes.Trim(bytes.Trim(b, `\"`), ` `)\n")
	b.WriteString("\tnewp, err := Parse" + rep.TypeInfo.Camel + "(b)\n")
	b.WriteString("\tif err != nil {\n")
	b.WriteString("\t\treturn err\n")
	b.WriteString("\t}\n")
	b.WriteString("\t*p = newp\n")
	b.WriteString("\treturn nil\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

func (g *Writer) writeIsValidMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("var valid" + rep.TypeInfo.PluralCamel + " = map[" + rep.TypeInfo.Camel + "]bool{\n")
	for _, info := range rep.Enums {
		if info.Info.Valid {
			b.WriteString("\t" + rep.TypeInfo.PluralCamel + "." + info.Info.Upper + ": true,\n")
		}
	}
	b.WriteString("}\n\n")
	b.WriteString("func (p " + rep.TypeInfo.Camel + ") IsValid() bool {\n")
	b.WriteString("\treturn valid" + rep.TypeInfo.PluralCamel + "[p]\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

func (g *Writer) writeExhaustiveMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("func Exhaustive" + rep.TypeInfo.Camel + "s(f func(" + rep.TypeInfo.Camel + ")) {\n")
	b.WriteString("\tfor _, p := range " + rep.TypeInfo.PluralCamel + ".allSlice() {\n")
	b.WriteString("\t\tf(p)\n")
	b.WriteString("\t}\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

func (g *Writer) writeImports(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("import (\n")
	b.WriteString("\t\"fmt\"\n")
	b.WriteString("\t\"strconv\"\n")
	if rep.CaseInsensitive {
		b.WriteString("\t\"strings\"\n")
	}
	b.WriteString("\t\"bytes\"\n")
	if !rep.Legacy {
		b.WriteString("\t\"iter\"\n")
	}
	b.WriteString("\t\"database/sql/driver\"\n")
	importedPkgs := make(map[string]bool)
	for _, pair := range rep.TypeInfo.NameTypePair {
		if strings.Contains(pair.Type, ".") {
			pkg := strings.Split(pair.Type, ".")[0]
			if !importedPkgs[pkg] {
				b.WriteString("\t\"" + pkg + "\"\n")
				importedPkgs[pkg] = true
			}
		}
	}
	b.WriteString(")\n\n")
	g.write(b.String())
}

func (g *Writer) writeWrapperType(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("type " + rep.TypeInfo.Camel + " struct {\n")
	b.WriteString(rep.TypeInfo.Name + "\n")
	for _, pair := range rep.TypeInfo.NameTypePair {
		b.WriteString("\t" + pair.Name + " " + pair.Type + "\n")
	}
	b.WriteString("}\n\n")
	b.WriteString("type " + rep.TypeInfo.Lower + "Container struct {\n")
	for _, info := range rep.Enums {
		b.WriteString("\t" + info.Info.Upper + " " + info.TypeInfo.Camel + "\n")
	}
	b.WriteString("}\n\n")
	b.WriteString("var " + rep.TypeInfo.PluralCamel + " = " + rep.TypeInfo.Lower + "Container{\n")
	for _, info := range rep.Enums {
		if info.Info.Valid {
			b.WriteString("\t" + info.Info.Upper + ": " + info.TypeInfo.Camel + "{ \n\t" + info.TypeInfo.Name + ":" + info.Info.Name + ",\n")
			for _, ntp := range info.TypeInfo.NameTypePair {
				b.WriteString(ntp.Name + ": " + ntp.Value + ",\n")
			}
			b.WriteString("},\n")
		}
	}
	b.WriteString("}\n\n")
	g.write(b.String())
}
func (g *Writer) writeAllMethod(rep enum.Representation) {
	var b strings.Builder

	// Private allSlice method for internal use
	b.WriteString("func (c " + rep.TypeInfo.Lower + "Container) allSlice() []" + rep.TypeInfo.Camel + " {\n")
	b.WriteString("\treturn []" + rep.TypeInfo.Camel + "{\n")
	for _, info := range rep.Enums {
		if info.Info.Valid {
			b.WriteString("\t\tc." + info.Info.Upper + ",\n")
		}
	}
	b.WriteString("\t}\n")
	b.WriteString("}\n\n")

	// Public AllSlice method that uses the private one
	b.WriteString("// AllSlice returns all valid " + rep.TypeInfo.Camel + " values as a slice.\n")
	if !rep.Legacy {
		b.WriteString("// Deprecated: Use All() with Go 1.23+ range over function types instead.\n")
	}
	b.WriteString("func (c " + rep.TypeInfo.Lower + "Container) AllSlice() []" + rep.TypeInfo.Camel + " {\n")
	b.WriteString("\treturn c.allSlice()\n")
	b.WriteString("}\n\n")

	// Always generate the All function, but with different implementations based on legacy mode
	b.WriteString("// All returns all valid " + rep.TypeInfo.Camel + " values.\n")

	if !rep.Legacy {
		// Modern implementation using iter.Seq for Go 1.23+
		b.WriteString("func (c " + rep.TypeInfo.Lower + "Container) All() iter.Seq[" + rep.TypeInfo.Camel + "] {\n")
		b.WriteString("\treturn func(yield func(" + rep.TypeInfo.Camel + ") bool) {\n")
		b.WriteString("\t\tfor _, v := range c.allSlice() {\n")
		b.WriteString("\t\t\tif !yield(v) {\n")
		b.WriteString("\t\t\t\treturn\n")
		b.WriteString("\t\t\t}\n")
		b.WriteString("\t\t}\n")
		b.WriteString("\t}\n")
	} else {
		// Legacy implementation simply returning a slice for older Go versions
		b.WriteString("func (c " + rep.TypeInfo.Lower + "Container) All() []" + rep.TypeInfo.Camel + " {\n")
		b.WriteString("\treturn c.allSlice()\n")
	}

	b.WriteString("}\n\n")

	// Write the entire buffer with a single call
	g.write(b.String())
}

func (g *Writer) writeInvalidTypeDefinition(rep enum.Representation) {
	g.write("var invalid" + rep.TypeInfo.Camel + " = " + rep.TypeInfo.Camel + "{}\n\n")
}
