package gofile

import (
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strconv"

	"time"

	"github.com/zarldev/goenums/enum"
	"github.com/zarldev/goenums/file"
	"github.com/zarldev/goenums/generator/config"
	"github.com/zarldev/goenums/strings"
)

var _ enum.Writer = &Writer{}

var (
	// ErrWriteGoFile is returned when an error occurs while writing the go file.
	ErrWriteGoFile = errors.New("error writing go file")
)

type Writer struct {
	Configuration config.Configuration
	w             io.Writer
	fs            file.ReadWriteCreateFileFS
}

type WriterOption func(*Writer)

func WithFileSystem(fs file.ReadWriteCreateFileFS) func(*Writer) {
	return func(w *Writer) {
		w.fs = fs
	}
}

func NewWriter(cfg config.Configuration, opts ...WriterOption) *Writer {
	w := Writer{
		Configuration: cfg,
		fs:            &file.OSReadWriteFileFS{},
		w:             os.Stdout,
	}
	for _, opt := range opts {
		opt(&w)
	}
	return &w
}

// Write implements enum.RepresentationWriter.
func (g *Writer) Write(ctx context.Context,
	enums []enum.Representation) error {
	for _, enumRep := range enums {
		if ctx.Err() != nil {
			return ctx.Err()
		}
		dirPath := filepath.Dir(enumRep.SourceFilename)
		outFilename := fmt.Sprintf("%s_enums.go", enumRep.TypeInfo.Lower)
		if strings.Contains(outFilename, " ") || strings.Contains(outFilename, "/") {
			return fmt.Errorf("%w: '%s' contains invalid characters", ErrWriteGoFile, outFilename)
		}
		fullPath := filepath.Join(dirPath, outFilename)
		err := file.WriteToFileAndFormatFS(ctx, g.fs, fullPath, true,
			func(w io.Writer) error {
				g.w = w
				g.writeEnumFile(enumRep)
				return nil
			})
		if err != nil {
			return fmt.Errorf("%w: %s: %w", ErrWriteGoFile, fullPath, err)
		}
	}
	return nil
}

func (g *Writer) writeEnumFile(enum enum.Representation) {
	// Top-level file structure
	g.writeGeneratedComment(enum)
	g.writePackage(enum)
	g.writeImports(enum)

	// Type definitions
	g.writeWrapperType(enum)
	g.writeInvalidTypeDefinition(enum)

	// Methods and functions
	g.writeAllMethod(enum)
	g.writeParsingMethods(enum)
	g.writeExhaustiveMethod(enum)
	g.writeIsValidMethod(enum)

	// Database and JSON handling
	g.writeJSONMarshalMethod(enum)
	g.writeJSONUnmarshalMethod(enum)
	g.writeScanMethod(enum)
	g.writeValueMethod(enum)

	// Other utility code
	g.writeCompileCheck(enum)
	g.writeStringMethod(enum)
}

// write writes a string to the output writer
// it is a wrapper around the io.Writer interface
func (g *Writer) write(s string) {
	_, _ = g.w.Write([]byte(s))
}

func (g *Writer) writeGeneratedComment(rep enum.Representation) {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("// Code generated by goenums %s at %s. DO NOT EDIT.\n",
		rep.Version, time.Now().Format(time.RFC3339)))
	b.WriteString("// This file was generated by github.com/zarldev/goenums \n")
	b.WriteString("// using the command:\n")
	b.WriteString("// goenums ")
	if rep.Failfast {
		b.WriteString("-f ")
	}
	if rep.Legacy {
		b.WriteString("-l ")
	}
	if rep.CaseInsensitive {
		b.WriteString("-i ")
	}
	b.WriteString(rep.SourceFilename + "\n")
	b.WriteString("\n")
	g.write(b.String())
}

func (g *Writer) writePackage(rep enum.Representation) {
	g.write("package " + rep.PackageName + "\n\n")
}

// New combined function for all parsing methods
func (g *Writer) writeParsingMethods(enum enum.Representation) {
	g.writeParseFunction(enum)

	g.writeStringParsingMethod(enum)
	g.writeIntParsingMethod(enum)
}

func (g *Writer) writeParseFunction(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("// Parse" + rep.TypeInfo.Camel + " converts various input types to a " + rep.TypeInfo.Camel + " value.\n")
	b.WriteString("// It accepts the following types:\n")
	b.WriteString("// - " + rep.TypeInfo.Camel + ": returns the value directly\n")
	b.WriteString("// - string: parses the string representation\n")
	b.WriteString("// - []byte: converts to string and parses\n")
	b.WriteString("// - fmt.Stringer: uses the String() result for parsing\n")
	b.WriteString("// - int/int32/int64: converts the integer to the corresponding enum value\n")
	if rep.Failfast {
		b.WriteString("//\n")
		b.WriteString("// If the input cannot be converted to a valid " + rep.TypeInfo.Camel + " value, it returns\n")
		b.WriteString("// the invalid" + rep.TypeInfo.Camel + " value and an error.\n")
	} else {
		b.WriteString("//\n")
		b.WriteString("// If the input cannot be converted to a valid " + rep.TypeInfo.Camel + " value, it returns\n")
		b.WriteString("// the invalid" + rep.TypeInfo.Camel + " value without an error.\n")
	}
	b.WriteString("func Parse" + rep.TypeInfo.Camel + "(a any) (" + rep.TypeInfo.Camel + ", error) {\n")
	b.WriteString("\tres := invalid" + rep.TypeInfo.Camel + "\n")
	b.WriteString("\tswitch v := a.(type) {\n")
	b.WriteString("\tcase " + rep.TypeInfo.Camel + ":\n")
	b.WriteString("\t\treturn v, nil\n")
	b.WriteString("\tcase []byte:\n")
	b.WriteString("\t\tres = stringTo" + rep.TypeInfo.Camel + "(string(v))\n")
	b.WriteString("\tcase string:\n")
	b.WriteString("\t\tres = stringTo" + rep.TypeInfo.Camel + "(v)\n")
	b.WriteString("\tcase fmt.Stringer:\n")
	b.WriteString("\t\tres = stringTo" + rep.TypeInfo.Camel + "(v.String())\n")
	b.WriteString("\tcase int:\n")
	b.WriteString("\t\tres = intTo" + rep.TypeInfo.Camel + "(v)\n")
	b.WriteString("\tcase int64:\n")
	b.WriteString("\t\tres = intTo" + rep.TypeInfo.Camel + "(int(v))\n")
	b.WriteString("\tcase int32:\n")
	b.WriteString("\t\tres = intTo" + rep.TypeInfo.Camel + "(int(v))\n")
	b.WriteString("\t}\n")
	if rep.Failfast {
		b.WriteString("\tif res == invalid" + rep.TypeInfo.Camel + " {\n")
		errorMsg := fmt.Sprintf("failed to parse %s value - invalid input: %%v", rep.TypeInfo.Camel)
		b.WriteString("\t\treturn res, fmt.Errorf(\"" + errorMsg + "\", a)\n")
		b.WriteString("\t}\n")
	}
	b.WriteString("\treturn res, nil\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

// Change from setupStringToTypeMethod to writeStringParsingMethod
func (g *Writer) writeStringParsingMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("// stringTo" + rep.TypeInfo.Camel + " is an internal function that converts a string to a " + rep.TypeInfo.Camel + " value.\n")
	b.WriteString("// It uses a predefined mapping of string representations to enum values.\n")
	if rep.CaseInsensitive {
		b.WriteString("// This implementation is case-insensitive.\n")
	}
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\t_%sNameMap = map[string]%s{\n", rep.TypeInfo.Lower, rep.TypeInfo.Camel))
	seen := make(map[string]bool)
	for _, info := range rep.Enums {
		original := info.Info.Alias
		lowercase := strings.ToLower(original)
		b.WriteString(fmt.Sprintf("\t\t%q: %s.%s,\n",
			original, rep.TypeInfo.PluralCamel, info.Info.Upper))
		if rep.CaseInsensitive && lowercase != original && !seen[lowercase] {
			b.WriteString(fmt.Sprintf("\t\t%q: %s.%s,\n",
				lowercase, rep.TypeInfo.PluralCamel, info.Info.Upper))
			seen[lowercase] = true
		}
	}
	b.WriteString("\t}\n")
	b.WriteString(")\n\n")
	b.WriteString("func stringTo" + rep.TypeInfo.Camel + "(s string) " + rep.TypeInfo.Camel + " {\n")
	b.WriteString(fmt.Sprintf("\tif v, ok := _%sNameMap[s]; ok {\n", rep.TypeInfo.Lower))
	b.WriteString("\t\treturn v\n")
	b.WriteString("\t}\n")
	if rep.CaseInsensitive {
		b.WriteString("\tlwr := strings.ToLower(s)\n")
		b.WriteString("\tif lwr != s {\n")
		b.WriteString(fmt.Sprintf("\t\tif v, ok := _%sNameMap[lwr]; ok {\n", rep.TypeInfo.Lower))
		b.WriteString("\t\t\treturn v\n")
		b.WriteString("\t\t}\n")
		b.WriteString("\t}\n")
	}
	b.WriteString("\treturn invalid" + rep.TypeInfo.Camel + "\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

// Change from setupIntToTypeMethod to writeIntParsingMethod
func (g *Writer) writeIntParsingMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("// intTo" + rep.TypeInfo.Camel + " converts an integer to a " + rep.TypeInfo.Camel + " value.\n")
	b.WriteString("// The integer is treated as the ordinal position in the enum sequence.\n")
	if rep.TypeInfo.Index != 0 {
		b.WriteString("// The input is adjusted by -" + strconv.Itoa(rep.TypeInfo.Index) + " to account for the enum starting value.\n")
	}
	b.WriteString("// If the integer doesn't correspond to a valid enum value, invalid" + rep.TypeInfo.Camel + " is returned.\n")
	b.WriteString("func intTo" + rep.TypeInfo.Camel + "(i int) " + rep.TypeInfo.Camel + " {\n")
	if rep.TypeInfo.Index != 0 {
		b.WriteString("\ti = i - " + strconv.Itoa(rep.TypeInfo.Index) + "\n")
	}
	b.WriteString("\tif i < 0 || i >= len(" + rep.TypeInfo.PluralCamel + ".allSlice()) {\n")
	b.WriteString("\t\treturn invalid" + rep.TypeInfo.Camel + "\n")
	b.WriteString("\t}\n")
	b.WriteString("\treturn " + rep.TypeInfo.PluralCamel + ".allSlice()[i]\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

func (g *Writer) writeScanMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("// Scan implements the sql.Scanner interface for " + rep.TypeInfo.Camel + ".\n")
	b.WriteString("// This allows " + rep.TypeInfo.Camel + " values to be scanned directly from database queries.\n")
	b.WriteString("// It supports scanning from strings, []byte, or integers.\n")
	b.WriteString("func (p *" + rep.TypeInfo.Camel + ") Scan(value any) error {\n")
	b.WriteString("\tnewp, err := Parse" + rep.TypeInfo.Camel + "(value)\n")
	b.WriteString("\tif err != nil {\n")
	b.WriteString("\t\treturn err\n")
	b.WriteString("\t}\n")
	b.WriteString("\t*p = newp\n")
	b.WriteString("\treturn nil\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

func (g *Writer) writeValueMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("// Value implements the driver.Valuer interface for " + rep.TypeInfo.Camel + ".\n")
	b.WriteString("// This allows " + rep.TypeInfo.Camel + " values to be saved to databases.\n")
	b.WriteString("// The value is stored as a string representation of the enum.\n")
	b.WriteString("func (p " + rep.TypeInfo.Camel + ") Value() (driver.Value, error) {\n")
	b.WriteString("\treturn p.String(), nil\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}
func (g *Writer) generateIndexAndNameRun(rep enum.Representation) (string, string) {
	var namesBuilder strings.Builder
	positions := make([]int, 0, len(rep.Enums)+rep.TypeInfo.Index+1)
	positions = append(positions, 0)
	for i := range rep.TypeInfo.Index {
		positions = append(positions, positions[i])
	}
	for _, enum := range rep.Enums {
		namesBuilder.WriteString(enum.Info.Alias)
		positions = append(positions, namesBuilder.Len())
	}
	nameStr := namesBuilder.String()
	nameConst := fmt.Sprintf("_%s_name = %q\n", rep.TypeInfo.Lower, nameStr)

	var indexBuilder strings.Builder
	indexBuilder.WriteString(fmt.Sprintf("_%s_index = [...]uint16{", rep.TypeInfo.Lower))

	for i, pos := range positions {
		if i > 0 {
			indexBuilder.WriteString(", ")
		}
		indexBuilder.WriteString(fmt.Sprintf("%d", pos))
	}
	indexBuilder.WriteString("}\n")
	return indexBuilder.String(), nameConst
}

func (g *Writer) writeStringMethod(rep enum.Representation) {
	indexVar, nameConst := g.generateIndexAndNameRun(rep)
	var b strings.Builder
	b.WriteString("const " + nameConst)
	b.WriteString("var " + indexVar)

	b.WriteString("// String returns the string representation of the " + rep.TypeInfo.Camel + " value.\n")
	b.WriteString("// For valid values, it returns the name of the constant.\n")
	b.WriteString("// For invalid values, it returns a string in the format \"" + rep.TypeInfo.Lower + "(N)\",\n")
	b.WriteString("// where N is the numeric value.\n")

	b.WriteString("func (i " + rep.TypeInfo.Name + ") String() string {\n")
	b.WriteString(fmt.Sprintf("\tif i < %d || i >= %s(len(_%s_index)-1) {\n",
		rep.TypeInfo.Index, rep.TypeInfo.Name, rep.TypeInfo.Lower))
	b.WriteString("\t\treturn \"" + rep.TypeInfo.Lower + "(\" + (strconv.FormatInt(int64(i), 10) + \")\")\n")
	b.WriteString("\t}\n")
	b.WriteString(fmt.Sprintf("\treturn _%s_name[_%s_index[i]:_%s_index[i+1]]\n",
		rep.TypeInfo.Lower, rep.TypeInfo.Lower, rep.TypeInfo.Lower))
	b.WriteString("}\n")
	g.write(b.String())
}

func (g *Writer) writeCompileCheck(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("func _() {\n")
	b.WriteString("\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n")
	b.WriteString("\t// Re-run the goenums command to generate them again.\n")
	b.WriteString("\t// Does not identify newly added constant values unless order changes\n")
	b.WriteString("\tvar x [1]struct{}\n")
	for _, v := range rep.Enums {
		b.WriteString(fmt.Sprintf("\t_ = x[%s - %d]\n", v.Info.Name, v.Info.Value+rep.TypeInfo.Index))
	}
	b.WriteString("}\n")
	g.write(b.String())
}

func (g *Writer) writeJSONMarshalMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("// MarshalJSON implements the json.Marshaler interface for " + rep.TypeInfo.Camel + ".\n")
	b.WriteString("// The enum value is encoded as its string representation.\n")
	b.WriteString("func (p " + rep.TypeInfo.Camel + ") MarshalJSON() ([]byte, error) {\n")
	b.WriteString("\treturn []byte(`\"`+p.String() + `\"`), nil\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

func (g *Writer) writeJSONUnmarshalMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("// UnmarshalJSON implements the json.Unmarshaler interface for " + rep.TypeInfo.Camel + ".\n")
	b.WriteString("// It supports unmarshaling from a string representation of the enum.\n")
	b.WriteString("func (p *" + rep.TypeInfo.Camel + ") UnmarshalJSON(b []byte) error {\n")
	b.WriteString("b = bytes.Trim(bytes.Trim(b, `\"`), ` `)\n")
	b.WriteString("\tnewp, err := Parse" + rep.TypeInfo.Camel + "(b)\n")
	b.WriteString("\tif err != nil {\n")
	b.WriteString("\t\treturn err\n")
	b.WriteString("\t}\n")
	b.WriteString("\t*p = newp\n")
	b.WriteString("\treturn nil\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

func (g *Writer) writeIsValidMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("// valid" + rep.TypeInfo.PluralCamel + " is a map of valid " + rep.TypeInfo.Camel + " values.\n")
	b.WriteString("var valid" + rep.TypeInfo.PluralCamel + " = map[" + rep.TypeInfo.Camel + "]bool{\n")
	for _, info := range rep.Enums {
		if info.Info.Valid {
			b.WriteString("\t" + rep.TypeInfo.PluralCamel + "." + info.Info.Upper + ": true,\n")
		}
	}
	b.WriteString("}\n\n")
	b.WriteString("// IsValid checks whether the " + rep.TypeInfo.Camel + " value is valid.\n")
	b.WriteString("// A valid value is one that is defined in the original enum and not marked as invalid.\n")
	b.WriteString("func (p " + rep.TypeInfo.Camel + ") IsValid() bool {\n")
	b.WriteString("\treturn valid" + rep.TypeInfo.PluralCamel + "[p]\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

func (g *Writer) writeExhaustiveMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("// Exhaustive" + rep.TypeInfo.Camel + "s calls the provided function once for each valid " + rep.TypeInfo.Camel + " value.\n")
	b.WriteString("// This is useful for switch statement exhaustiveness checking and for processing all enum values.\n")
	b.WriteString("// Example usage:\n")
	b.WriteString("// ```\n")
	b.WriteString("// Exhaustive" + rep.TypeInfo.Camel + "s(func(x " + rep.TypeInfo.Camel + ") {\n")
	b.WriteString("//     switch x {\n")
	b.WriteString("//     case " + rep.TypeInfo.PluralCamel + ".VALUE1:\n")
	b.WriteString("//         // handle VALUE1\n")
	b.WriteString("//     }\n")
	b.WriteString("// })\n")
	b.WriteString("// ```\n")
	b.WriteString("func Exhaustive" + rep.TypeInfo.Camel + "s(f func(" + rep.TypeInfo.Camel + ")) {\n")
	b.WriteString("\tfor _, p := range " + rep.TypeInfo.PluralCamel + ".allSlice() {\n")
	b.WriteString("\t\tf(p)\n")
	b.WriteString("\t}\n")
	b.WriteString("}\n\n")
	g.write(b.String())
}

func (g *Writer) writeImports(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("import (\n")
	b.WriteString("\t\"fmt\"\n")
	b.WriteString("\t\"strconv\"\n")
	if rep.CaseInsensitive {
		b.WriteString("\t\"strings\"\n")
	}
	b.WriteString("\t\"bytes\"\n")
	if !rep.Legacy {
		b.WriteString("\t\"iter\"\n")
	}
	b.WriteString("\t\"database/sql/driver\"\n")
	importedPkgs := make(map[string]bool)
	for _, pair := range rep.TypeInfo.NameTypePair {
		if strings.Contains(pair.Type, ".") {
			pkg := strings.Split(pair.Type, ".")[0]
			if !importedPkgs[pkg] {
				b.WriteString("\t\"" + pkg + "\"\n")
				importedPkgs[pkg] = true
			}
		}
	}
	b.WriteString(")\n\n")
	g.write(b.String())
}

func (g *Writer) writeWrapperType(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("type " + rep.TypeInfo.Camel + " struct {\n")
	b.WriteString(rep.TypeInfo.Name + "\n")
	for _, pair := range rep.TypeInfo.NameTypePair {
		b.WriteString("\t" + pair.Name + " " + pair.Type + "\n")
	}
	b.WriteString("}\n\n")
	b.WriteString("type " + rep.TypeInfo.Lower + "Container struct {\n")
	for _, info := range rep.Enums {
		b.WriteString("\t" + info.Info.Upper + " " + info.TypeInfo.Camel + "\n")
	}
	b.WriteString("}\n\n")
	b.WriteString("var " + rep.TypeInfo.PluralCamel + " = " + rep.TypeInfo.Lower + "Container{\n")
	for _, info := range rep.Enums {
		if info.Info.Valid {
			b.WriteString("\t" + info.Info.Upper + ": " + info.TypeInfo.Camel + "{ \n\t" + info.TypeInfo.Name + ":" + info.Info.Name + ",\n")
			for _, ntp := range info.TypeInfo.NameTypePair {
				b.WriteString(ntp.Name + ": " + ntp.Value + ",\n")
			}
			b.WriteString("},\n")
		}
	}
	b.WriteString("}\n\n")
	g.write(b.String())
}
func (g *Writer) writeAllMethod(rep enum.Representation) {
	var b strings.Builder
	b.WriteString("// allSlice is an internal method that returns all valid " + rep.TypeInfo.Camel + " values as a slice.\n")
	b.WriteString("func (c " + rep.TypeInfo.Lower + "Container) allSlice() []" + rep.TypeInfo.Camel + " {\n")
	b.WriteString("\treturn []" + rep.TypeInfo.Camel + "{\n")
	for _, info := range rep.Enums {
		if info.Info.Valid {
			b.WriteString("\t\tc." + info.Info.Upper + ",\n")
		}
	}
	b.WriteString("\t}\n")
	b.WriteString("}\n\n")
	b.WriteString("// AllSlice returns all valid " + rep.TypeInfo.Camel + " values as a slice.\n")
	if !rep.Legacy {
		b.WriteString("// Deprecated: Use All() with Go 1.23+ range over function types instead.\n")
	}
	b.WriteString("func (c " + rep.TypeInfo.Lower + "Container) AllSlice() []" + rep.TypeInfo.Camel + " {\n")
	b.WriteString("\treturn c.allSlice()\n")
	b.WriteString("}\n\n")
	b.WriteString("// All returns all valid " + rep.TypeInfo.Camel + " values.\n")
	if !rep.Legacy {
		b.WriteString("// In Go 1.23+, this can be used with range-over-function iteration:\n")
		b.WriteString("// ```\n")
		b.WriteString("// for v := range " + rep.TypeInfo.PluralCamel + ".All() {\n")
		b.WriteString("//     // process each enum value\n")
		b.WriteString("// }\n")
		b.WriteString("// ```\n")
	} else {
		b.WriteString("// Returns a slice of all valid enum values.\n")
	}
	if !rep.Legacy {
		b.WriteString("func (c " + rep.TypeInfo.Lower + "Container) All() iter.Seq[" + rep.TypeInfo.Camel + "] {\n")
		b.WriteString("\treturn func(yield func(" + rep.TypeInfo.Camel + ") bool) {\n")
		b.WriteString("\t\tfor _, v := range c.allSlice() {\n")
		b.WriteString("\t\t\tif !yield(v) {\n")
		b.WriteString("\t\t\t\treturn\n")
		b.WriteString("\t\t\t}\n")
		b.WriteString("\t\t}\n")
		b.WriteString("\t}\n")
	} else {
		b.WriteString("func (c " + rep.TypeInfo.Lower + "Container) All() []" + rep.TypeInfo.Camel + " {\n")
		b.WriteString("\treturn c.allSlice()\n")
	}
	b.WriteString("}\n\n")
	g.write(b.String())
}

func (g *Writer) writeInvalidTypeDefinition(rep enum.Representation) {
	g.write("// invalid" + rep.TypeInfo.Camel + " represents an invalid or undefined " + rep.TypeInfo.Camel + " value.\n")
	g.write("// It is used as a default return value for failed parsing or conversion operations.\n")
	g.write("var invalid" + rep.TypeInfo.Camel + " = " + rep.TypeInfo.Camel + "{}\n\n")
}
