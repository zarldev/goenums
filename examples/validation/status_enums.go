// DO NOT EDIT.
// code generated by goenums 'v0.3.10' at 2025-05-05 12:37:43.
// github.com/zarldev/goenums
//
// using the command:
//
// goenums status.go

package validation

import (
	"bytes"
	"database/sql/driver"
	"fmt"
	"iter"
	"strconv"
)

type Status struct {
	status
}

type statusContainer struct {
	FAILED    Status
	PASSED    Status
	SKIPPED   Status
	SCHEDULED Status
	RUNNING   Status
	BOOKED    Status
}

var Status = statusContainer{
	PASSED: Status{
		status: passed,
	},
	SKIPPED: Status{
		status: skipped,
	},
	SCHEDULED: Status{
		status: scheduled,
	},
	RUNNING: Status{
		status: running,
	},
	BOOKED: Status{
		status: booked,
	},
}

// invalidStatus represents an invalid or undefined Status value.
// It is used as a default return value for failed parsing or conversion operations.
var invalidStatus = Status{}

// allSlice is an internal method that returns all valid Status values as a slice.
func (c statusContainer) allSlice() []Status {
	return []Status{
		c.PASSED,
		c.SKIPPED,
		c.SCHEDULED,
		c.RUNNING,
		c.BOOKED,
	}
}

// AllSlice returns all valid Status values as a slice.
func (c statusContainer) AllSlice() []Status {
	return c.allSlice()
}

// All returns all valid Status values.
// In Go 1.23+, this can be used with range-over-function iteration:
// ```
//
//	for v := range Status.All() {
//	    // process each enum value
//	}
//
// ```
func (c statusContainer) All() iter.Seq[Status] {
	return func(yield func(Status) bool) {
		for _, v := range c.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// ParseStatus converts various input types to a Status value.
// It accepts the following types:
// - Status: returns the value directly
// - string: parses the string representation
// - []byte: converts to string and parses
// - fmt.Stringer: uses the String() result for parsing
// - int/int32/int64: converts the integer to the corresponding enum value
//
// If the input cannot be converted to a valid Status value, it returns
// the invalidStatus value without an error.
func ParseStatus(a any) (Status, error) {
	res := invalidStatus
	switch v := a.(type) {
	case Status:
		return v, nil
	case []byte:
		res = stringToStatus(string(v))
	case string:
		res = stringToStatus(v)
	case fmt.Stringer:
		res = stringToStatus(v.String())
	case int:
		res = intToStatus(v)
	case int64:
		res = intToStatus(int(v))
	case int32:
		res = intToStatus(int(v))
	}
	return res, nil
}

// stringToStatus is an internal function that converts a string to a Status value.
// It uses a predefined mapping of string representations to enum values.
var (
	statusNameMap = map[string]Status{
		"FAILED":    Status.FAILED,    // primary alias
		"failed":    Status.FAILED,    // enum name
		"PASSED":    Status.PASSED,    // primary alias
		"passed":    Status.PASSED,    // enum name
		"SKIPPED":   Status.SKIPPED,   // primary alias
		"skipped":   Status.SKIPPED,   // enum name
		"SCHEDULED": Status.SCHEDULED, // primary alias
		"scheduled": Status.SCHEDULED, // enum name
		"RUNNING":   Status.RUNNING,   // primary alias
		"running":   Status.RUNNING,   // enum name
		"BOOKED":    Status.BOOKED,    // primary alias
		"booked":    Status.BOOKED,    // enum name
	}
)

func stringToStatus(s string) Status {
	if v, ok := statusNameMap[s]; ok {
		return v
	}
	return invalidStatus
}

// intToStatus converts an integer to a Status value.
// The integer is treated as the ordinal position in the enum sequence.
// The input is adjusted by -6 to account for the enum starting value.
// If the integer doesn't correspond to a valid enum value, invalidStatus is returned.
func intToStatus(i int) Status {
	if i < 0 || i >= len(Status.allSlice()) {
		return invalidStatus
	}
	return Status.allSlice()[i]
}

// ExhaustiveStatus calls the provided function once for each valid Status value.
// This is useful for switch statement exhaustiveness checking and for processing all enum values.
// Example usage:
// ```
//
//	ExhaustiveStatus(func(x Status) {
//	    switch x {
//	    case Status.Booked:
//	        // handle Booked
//	    }
//	})
//
// ```
func ExhaustiveStatus(f func(Status)) {
	for _, p := range Status.allSlice() {
		f(p)
	}
}

// validStatus is a map of valid Status values.
var validStatus = map[Status]bool{
	Status.PASSED:    true,
	Status.SKIPPED:   true,
	Status.SCHEDULED: true,
	Status.RUNNING:   true,
	Status.BOOKED:    true,
}

// IsValid checks whether the Status value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (p Status) IsValid() bool {
	return validStatus[p]
}

// MarshalJSON implements the json.Marshaler interface for Status.
// The enum value is encoded as its string representation.
func (p Status) MarshalJSON() ([]byte, error) {
	return []byte(`"` + p.String() + `"`), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface for Status.
// It supports unmarshaling from a string representation of the enum.
func (p *Status) UnmarshalJSON(b []byte) error {
	b = bytes.Trim(bytes.Trim(b, `"`), ` `)
	newp, err := ParseStatus(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// Scan implements the sql.Scanner interface for Status.
// This allows Status values to be scanned directly from database queries.
// It supports scanning from strings, []byte, or integers.
func (p *Status) Scan(value any) error {
	newp, err := ParseStatus(value)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// Value implements the driver.Valuer interface for Status.
// This allows Status values to be saved to databases.
// The value is stored as a string representation of the enum.
func (p Status) Value() (driver.Value, error) {
	return p.String(), nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for Status.
// It encodes the enum value as a byte slice.
func (p Status) MarshalBinary() ([]byte, error) {
	return []byte(p.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for Status.
// It decodes the enum value from a byte slice.
func (p *Status) UnmarshalBinary(b []byte) error {
	newp, err := ParseStatus(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for Status.
// The enum value is encoded as its string representation.
func (p Status) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Status.
// It supports unmarshaling from a string representation of the enum.
func (p *Status) UnmarshalText(b []byte) error {
	newp, err := ParseStatus(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [1]struct{}
	_ = x[failed-0]
	_ = x[passed-1]
	_ = x[skipped-2]
	_ = x[scheduled-3]
	_ = x[running-4]
	_ = x[booked-5]
}

const statusName = "FAILEDPASSEDSKIPPEDSCHEDULEDRUNNINGBOOKED"

var statusIdx = [...]uint16{0, 6, 12, 19, 28, 35, 41}

// String returns the string representation of the Status value.
// For valid values, it returns the name of the constant.
// For invalid values, it returns a string in the format "status(N)",
// where N is the numeric value.
func (i status) String() string {
	if i < 0 || i > status(len(statusIdx)-1)+-1 {
		return "status(" + (strconv.FormatInt(int64(i), 10) + ")")
	}
	return statusName[statusIdx[i]:statusIdx[i+1]]
}
