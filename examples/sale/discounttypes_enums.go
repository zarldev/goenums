// DO NOT EDIT.
// code generated by goenums 'v0.3.10' at 2025-05-05 12:37:43.
// github.com/zarldev/goenums
//
// using the command:
//
// goenums -f discount.go

package sale

import (
	"bytes"
	"database/sql/driver"
	"fmt"
	"iter"
	"strconv"
	"time"
)

type DiscountTypes struct {
	discountTypes
	Available bool
	Started   bool
	Finished  bool
	Cancelled bool
	Duration  time.Duration
}

type discountTypesContainer struct {
	SALE       DiscountTypes
	PERCENTAGE DiscountTypes
	AMOUNT     DiscountTypes
	GIVEAWAY   DiscountTypes
}

var DiscountTypes = discountTypesContainer{
	SALE: DiscountTypes{
		discountTypes: sale,
		Available:     false,
		Started:       true,
		Finished:      true,
		Cancelled:     false,
		Duration:      time.Hour * 172,
	},
	PERCENTAGE: DiscountTypes{
		discountTypes: percentage,
		Available:     false,
		Started:       false,
		Finished:      false,
		Cancelled:     false,
		Duration:      time.Hour * 24,
	},
	AMOUNT: DiscountTypes{
		discountTypes: amount,
		Available:     false,
		Started:       false,
		Finished:      false,
		Cancelled:     false,
		Duration:      time.Hour * 48,
	},
	GIVEAWAY: DiscountTypes{
		discountTypes: giveaway,
		Available:     true,
		Started:       true,
		Finished:      false,
		Cancelled:     false,
		Duration:      time.Hour * 72,
	},
}

// invalidDiscountTypes represents an invalid or undefined DiscountTypes value.
// It is used as a default return value for failed parsing or conversion operations.
var invalidDiscountTypes = DiscountTypes{}

// allSlice is an internal method that returns all valid DiscountTypes values as a slice.
func (c discountTypesContainer) allSlice() []DiscountTypes {
	return []DiscountTypes{
		c.SALE,
		c.PERCENTAGE,
		c.AMOUNT,
		c.GIVEAWAY,
	}
}

// AllSlice returns all valid DiscountTypes values as a slice.
func (c discountTypesContainer) AllSlice() []DiscountTypes {
	return c.allSlice()
}

// All returns all valid DiscountTypes values.
// In Go 1.23+, this can be used with range-over-function iteration:
// ```
//
//	for v := range DiscountTypes.All() {
//	    // process each enum value
//	}
//
// ```
func (c discountTypesContainer) All() iter.Seq[DiscountTypes] {
	return func(yield func(DiscountTypes) bool) {
		for _, v := range c.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// ParseDiscountTypes converts various input types to a DiscountTypes value.
// It accepts the following types:
// - DiscountTypes: returns the value directly
// - string: parses the string representation
// - []byte: converts to string and parses
// - fmt.Stringer: uses the String() result for parsing
// - int/int32/int64: converts the integer to the corresponding enum value
//
// If the input cannot be converted to a valid DiscountTypes value, it returns
// the invalidDiscountTypes value and an error.
func ParseDiscountTypes(a any) (DiscountTypes, error) {
	res := invalidDiscountTypes
	switch v := a.(type) {
	case DiscountTypes:
		return v, nil
	case []byte:
		res = stringToDiscountTypes(string(v))
	case string:
		res = stringToDiscountTypes(v)
	case fmt.Stringer:
		res = stringToDiscountTypes(v.String())
	case int:
		res = intToDiscountTypes(v)
	case int64:
		res = intToDiscountTypes(int(v))
	case int32:
		res = intToDiscountTypes(int(v))
	}
	if res == invalidDiscountTypes {
		return res, fmt.Errorf("failed to parse DiscountTypes value - invalid input: %v", a)
	}
	return res, nil
}

// stringToDiscountTypes is an internal function that converts a string to a DiscountTypes value.
// It uses a predefined mapping of string representations to enum values.
var (
	discountTypesNameMap = map[string]DiscountTypes{
		"sale":       DiscountTypes.SALE,       // primary alias
		"percentage": DiscountTypes.PERCENTAGE, // primary alias
		"amount":     DiscountTypes.AMOUNT,     // primary alias
		"giveaway":   DiscountTypes.GIVEAWAY,   // primary alias
	}
)

func stringToDiscountTypes(s string) DiscountTypes {
	if v, ok := discountTypesNameMap[s]; ok {
		return v
	}
	return invalidDiscountTypes
}

// intToDiscountTypes converts an integer to a DiscountTypes value.
// The integer is treated as the ordinal position in the enum sequence.
// The input is adjusted by -5 to account for the enum starting value.
// If the integer doesn't correspond to a valid enum value, invalidDiscountTypes is returned.
func intToDiscountTypes(i int) DiscountTypes {
	i -= 1
	if i < 0 || i >= len(DiscountTypes.allSlice()) {
		return invalidDiscountTypes
	}
	return DiscountTypes.allSlice()[i]
}

// ExhaustiveDiscountTypes calls the provided function once for each valid DiscountTypes value.
// This is useful for switch statement exhaustiveness checking and for processing all enum values.
// Example usage:
// ```
//
//	ExhaustiveDiscountTypes(func(x DiscountTypes) {
//	    switch x {
//	    case DiscountTypes.Giveaway:
//	        // handle Giveaway
//	    }
//	})
//
// ```
func ExhaustiveDiscountTypes(f func(DiscountTypes)) {
	for _, p := range DiscountTypes.allSlice() {
		f(p)
	}
}

// validDiscountTypes is a map of valid DiscountTypes values.
var validDiscountTypes = map[DiscountTypes]bool{
	DiscountTypes.SALE:       true,
	DiscountTypes.PERCENTAGE: true,
	DiscountTypes.AMOUNT:     true,
	DiscountTypes.GIVEAWAY:   true,
}

// IsValid checks whether the DiscountTypes value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (p DiscountTypes) IsValid() bool {
	return validDiscountTypes[p]
}

// MarshalJSON implements the json.Marshaler interface for DiscountTypes.
// The enum value is encoded as its string representation.
func (p DiscountTypes) MarshalJSON() ([]byte, error) {
	return []byte(`"` + p.String() + `"`), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface for DiscountTypes.
// It supports unmarshaling from a string representation of the enum.
func (p *DiscountTypes) UnmarshalJSON(b []byte) error {
	b = bytes.Trim(bytes.Trim(b, `"`), ` `)
	newp, err := ParseDiscountTypes(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// Scan implements the sql.Scanner interface for DiscountTypes.
// This allows DiscountTypes values to be scanned directly from database queries.
// It supports scanning from strings, []byte, or integers.
func (p *DiscountTypes) Scan(value any) error {
	newp, err := ParseDiscountTypes(value)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// Value implements the driver.Valuer interface for DiscountTypes.
// This allows DiscountTypes values to be saved to databases.
// The value is stored as a string representation of the enum.
func (p DiscountTypes) Value() (driver.Value, error) {
	return p.String(), nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for DiscountTypes.
// It encodes the enum value as a byte slice.
func (p DiscountTypes) MarshalBinary() ([]byte, error) {
	return []byte(p.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for DiscountTypes.
// It decodes the enum value from a byte slice.
func (p *DiscountTypes) UnmarshalBinary(b []byte) error {
	newp, err := ParseDiscountTypes(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for DiscountTypes.
// The enum value is encoded as its string representation.
func (p DiscountTypes) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for DiscountTypes.
// It supports unmarshaling from a string representation of the enum.
func (p *DiscountTypes) UnmarshalText(b []byte) error {
	newp, err := ParseDiscountTypes(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [1]struct{}
	_ = x[sale-1]
	_ = x[percentage-2]
	_ = x[amount-3]
	_ = x[giveaway-4]
}

const discountTypesName = "salepercentageamountgiveaway"

var discountTypesIdx = [...]uint16{0, 4, 14, 20, 28}

// String returns the string representation of the DiscountTypes value.
// For valid values, it returns the name of the constant.
// For invalid values, it returns a string in the format "discountTypes(N)",
// where N is the numeric value.
func (i discountTypes) String() string {
	if i < 1 || i > discountTypes(len(discountTypesIdx)-1)+0 {
		return "discountTypes(" + (strconv.FormatInt(int64(i), 10) + ")")
	}
	index := int(i) - 1
	return discountTypesName[discountTypesIdx[index]:discountTypesIdx[index+1]]
}
