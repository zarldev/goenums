// code generated by goenums 'v0.4.0' at May 28 03:10:17. DO NOT EDIT.
//
// github.com/zarldev/goenums
//
// using the command:
// goenums  -fdiscount.go

package sale

import (
	"bytes"
	"context"
	"database/sql/driver"
	"fmt"
	"iter"
	"math"
	"time"

	"golang.org/x/exp/constraints"
)

// DiscountType is a type that represents a single enum value.
// It combines the core information about the enum constant and it's defined fields.
type DiscountType struct {
	discountTypes
	Available bool
	Started   bool
	Finished  bool
	Cancelled bool
	Duration  time.Duration
}

// discountTypesContainer is the container for all enum values.
// It is private and should not be used directly use the public methods on the DiscountType type.
type discountTypesContainer struct {
	SALE       DiscountType
	PERCENTAGE DiscountType
	AMOUNT     DiscountType
	GIVEAWAY   DiscountType
}

// DiscountTypes is a main entry point using the DiscountType type.
// It it a container for all enum values and provides a convenient way to access all enum values and perform
// operations, with convenience methods for common use cases.
var DiscountTypes = discountTypesContainer{
	SALE: DiscountType{
		discountTypes: sale,
		Available:     false,
		Started:       true,
		Finished:      true,
		Cancelled:     false,
		Duration:      time.Hour * 172,
	},
	PERCENTAGE: DiscountType{
		discountTypes: percentage,
		Available:     false,
		Started:       false,
		Finished:      false,
		Cancelled:     false,
		Duration:      time.Hour * 24,
	},
	AMOUNT: DiscountType{
		discountTypes: amount,
		Available:     false,
		Started:       false,
		Finished:      false,
		Cancelled:     false,
		Duration:      time.Hour * 48,
	},
	GIVEAWAY: DiscountType{
		discountTypes: giveaway,
		Available:     true,
		Started:       true,
		Finished:      false,
		Cancelled:     false,
		Duration:      time.Hour * 72,
	},
}

// invalidDiscountType is an invalid sentinel value for DiscountType
var invalidDiscountType = DiscountType{}

// allSlice returns a slice of all enum values.
// This method is useful for iterating over all enum values in a loop.
func (d discountTypesContainer) allSlice() []DiscountType {
	return []DiscountType{
		DiscountTypes.SALE,
		DiscountTypes.PERCENTAGE,
		DiscountTypes.AMOUNT,
		DiscountTypes.GIVEAWAY,
	}
}

// All returns an iterator over all enum values.
// This method is useful for iterating over all enum values in a loop.
func (d discountTypesContainer) All() iter.Seq[DiscountType] {
	return func(yield func(DiscountType) bool) {
		for _, v := range d.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// ParseDiscountType parses the input value into an enum value.
// It returns the parsed enum value or an error if the input is invalid.
// It is a convenience function that can be used to parse enum values from
// various input types, such as strings, byte slices, or other enum types.
func ParseDiscountType(input any) (DiscountType, error) {
	var res = invalidDiscountType
	switch v := input.(type) {
	case DiscountType:
		return v, nil
	case string:
		res = stringToDiscountType(v)
	case fmt.Stringer:
		res = stringToDiscountType(v.String())
	case []byte:
		res = stringToDiscountType(string(v))
	case int:
		res = numberToDiscountType(v)
	case int8:
		res = numberToDiscountType(v)
	case int16:
		res = numberToDiscountType(v)
	case int32:
		res = numberToDiscountType(v)
	case int64:
		res = numberToDiscountType(v)
	case uint:
		res = numberToDiscountType(v)
	case uint8:
		res = numberToDiscountType(v)
	case uint16:
		res = numberToDiscountType(v)
	case uint32:
		res = numberToDiscountType(v)
	case uint64:
		res = numberToDiscountType(v)
	case float32:
		res = numberToDiscountType(v)
	case float64:
		res = numberToDiscountType(v)
	default:
		return res, fmt.Errorf("invalid type %T", input)
	}
	if res == invalidDiscountType {
		return res, fmt.Errorf("invalid value %v", input)
	}
	return res, nil
}

// discountTypesNameMap is a map of enum values to their DiscountType representation
// It is used to convert string representations of enum values into their DiscountType representation.
var discountTypesNameMap = map[string]DiscountType{}

// stringToDiscountType converts a string representation of an enum value into its DiscountType representation
// It returns the DiscountType representation of the enum value if the string is valid
// Otherwise, it returns invalidDiscountType
func stringToDiscountType(s string) DiscountType {
	if t, ok := discountTypesNameMap[s]; ok {
		return t
	}
	return invalidDiscountType
}

// numberToDiscountType converts a numeric value to a DiscountType
// It returns the DiscountType representation of the enum value if the numeric value is valid
// Otherwise, it returns invalidDiscountType
func numberToDiscountType[T constraints.Integer | constraints.Float](num T) DiscountType {
	f := float64(num)
	if math.Floor(f) != f {
		return invalidDiscountType
	}
	i := int(f)
	if i <= 0 || i > len(DiscountTypes.allSlice()) {
		return invalidDiscountType
	}
	return DiscountTypes.allSlice()[i-1]
}

// ExhaustiveDiscountTypes iterates over all enum values and calls the provided function for each value.
// This function is useful for performing operations on all valid enum values in a loop.
func ExhaustiveDiscountTypes(f func(DiscountType)) {
	for _, p := range DiscountTypes.allSlice() {
		f(p)
	}
}

// validDiscountTypes is a map of enum values to their validity
var validDiscountTypes = map[DiscountType]bool{
	DiscountTypes.SALE:       true,
	DiscountTypes.PERCENTAGE: true,
	DiscountTypes.AMOUNT:     true,
	DiscountTypes.GIVEAWAY:   true,
}

// IsValid checks whether the DiscountTypes value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (d DiscountType) IsValid() bool {
	return validDiscountTypes[d]
}

// MarshalJSON implements the json.Marshaler interface for DiscountType.
// It returns the JSON representation of the enum value as a byte slice.
func (d DiscountType) MarshalJSON() ([]byte, error) {
	return []byte("\"" + d.String() + "\""), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface for DiscountType.
// It parses the JSON representation of the enum value from the byte slice.
// It returns an error if the input is not a valid JSON representation.
func (d *DiscountType) UnmarshalJSON(b []byte) error {
	b = bytes.Trim(bytes.Trim(b, "\""), "\"")
	newd, err := ParseDiscountType(b)
	if err != nil {
		return err
	}
	*d = newd
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for DiscountType.
// It returns the string representation of the enum value as a byte slice
func (d DiscountType) MarshalText() ([]byte, error) {
	return []byte("\"" + d.String() + "\""), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for DiscountType.
// It parses the string representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (d *DiscountType) UnmarshalText(b []byte) error {
	newd, err := ParseDiscountType(b)
	if err != nil {
		return err
	}
	*d = newd
	return nil
}

// Scan implements the database/sql.Scanner interface for DiscountType.
// It parses the string representation of the enum value from the database row.
// It returns an error if the row does not contain a valid enum value.
func (d *DiscountType) Scan(value any) error {
	newd, err := ParseDiscountType(value)
	if err != nil {
		return err
	}
	*d = newd
	return nil
}

// Value implements the database/sql/driver.Valuer interface for DiscountType.
// It returns the string representation of the enum value.
func (d DiscountType) Value() (driver.Value, error) {
	return d.String(), nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for DiscountType.
// It returns the binary representation of the enum value as a byte slice.
func (d DiscountType) MarshalBinary() ([]byte, error) {
	return []byte("\"" + d.String() + "\""), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for DiscountType.
// It parses the binary representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (d *DiscountType) UnmarshalBinary(b []byte) error {
	newd, err := ParseDiscountType(b)
	if err != nil {
		return err
	}
	*d = newd
	return nil
}

// MarshalYAML implements the yaml.Marshaler interface for DiscountType.
// It returns the string representation of the enum value.
// It returns an error if the enum value is invalid.
func (d DiscountType) MarshalYAML() (any, error) {
	return d.String(), nil
}

// UnmarshalYAML implements the yaml.Unmarshaler interface for DiscountType.
// It parses the string representation of the enum value from the YAML node.
// It returns an error if the YAML node does not contain a valid enum value.
func (d *DiscountType) UnmarshalYAML(ctx context.Context, f func(any) error) error {
	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
	}
	return f(d.String())
}

// discounttypesNames is a constant string slice containing all enum values cononical absolute names
const discounttypesNames = "salepercentageamountgiveaway"

// discounttypesNamesMap is a map of enum values to their canonical absolute
// name positions within the discounttypesNames string slice
var discounttypesNamesMap = map[DiscountType]string{
	DiscountTypes.SALE:       discounttypesNames[0:4],
	DiscountTypes.PERCENTAGE: discounttypesNames[4:14],
	DiscountTypes.AMOUNT:     discounttypesNames[14:20],
	DiscountTypes.GIVEAWAY:   discounttypesNames[20:28],
}

// String implements the Stringer interface.
// It returns the canonical absolute name of the enum value.
func (d DiscountType) String() string {
	if str, ok := discounttypesNamesMap[d]; ok {
		return str
	}
	return fmt.Sprintf("discounttypes(%d)", d.discountTypes)
}

// Compile-time check that all enum values are valid.
// This function is used to ensure that all enum values are defined and valid.
// It is called by the compiler to verify that the enum values are valid.
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [4]struct{}
	_ = x[sale-1]
	_ = x[percentage-2]
	_ = x[amount-3]
	_ = x[giveaway-4]
}
