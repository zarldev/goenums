// DO NOT EDIT.
// code generated by goenums 'v0.4.2' at Jun 30 01:30:48.
//
// github.com/zarldev/goenums
//
// using the command:
// goenums -f -c negative.go

package crypto

import (
	"bytes"
	"database/sql/driver"
	"errors"
	"fmt"
	"iter"
	"math"
)

// Algorithm is a type that represents a single enum value.
// It combines the core information about the enum constant and it's defined fields.
type Algorithm struct {
	algorithm
}

// algorithmsContainer is the container for all enum values.
// It is private and should not be used directly use the public methods on the Algorithm type.
type algorithmsContainer struct {
	NONE     Algorithm
	AES256   Algorithm
	CHACHA20 Algorithm
}

// Algorithms is a main entry point using the Algorithm type.
// It it a container for all enum values and provides a convenient way to access all enum values and perform
// operations, with convenience methods for common use cases.
var Algorithms = algorithmsContainer{
	NONE: Algorithm{
		algorithm: None,
	},
	AES256: Algorithm{
		algorithm: AES256,
	},
	CHACHA20: Algorithm{
		algorithm: ChaCha20,
	},
}

// invalidAlgorithm is an invalid sentinel value for Algorithm
var invalidAlgorithm = Algorithm{
	algorithm: 2,
}

// allSlice returns a slice of all enum values.
// This method is useful for iterating over all enum values in a loop.
func (a algorithmsContainer) allSlice() []Algorithm {
	return []Algorithm{
		Algorithms.AES256,
		Algorithms.CHACHA20,
	}
}

// All returns an iterator over all enum values.
// This method is useful for iterating over all enum values in a loop.
func (a algorithmsContainer) All() iter.Seq[Algorithm] {
	return func(yield func(Algorithm) bool) {
		for _, v := range a.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

var ErrParseAlgorithm = errors.New("invalid input provided to parse to Algorithm")

// ParseAlgorithm parses the input value into an enum value.
// It returns the parsed enum value or an error if the input is invalid.
// It is a convenience function that can be used to parse enum values from
// various input types, such as strings, byte slices, or other enum types.
func ParseAlgorithm(input any) (Algorithm, error) {
	switch v := input.(type) {
	case Algorithm:
		return v, nil
	case string:
		if result := stringToAlgorithm(v); result != nil {
			return *result, nil
		}
	case fmt.Stringer:
		if result := stringToAlgorithm(v.String()); result != nil {
			return *result, nil
		}
	case []byte:
		if result := stringToAlgorithm(string(v)); result != nil {
			return *result, nil
		}
	case int:
		if result := numberToAlgorithm(v); result != nil {
			return *result, nil
		}
	case int8:
		if result := numberToAlgorithm(v); result != nil {
			return *result, nil
		}
	case int16:
		if result := numberToAlgorithm(v); result != nil {
			return *result, nil
		}
	case int32:
		if result := numberToAlgorithm(v); result != nil {
			return *result, nil
		}
	case int64:
		if result := numberToAlgorithm(v); result != nil {
			return *result, nil
		}
	case uint:
		if result := numberToAlgorithm(v); result != nil {
			return *result, nil
		}
	case uint8:
		if result := numberToAlgorithm(v); result != nil {
			return *result, nil
		}
	case uint16:
		if result := numberToAlgorithm(v); result != nil {
			return *result, nil
		}
	case uint32:
		if result := numberToAlgorithm(v); result != nil {
			return *result, nil
		}
	case uint64:
		if result := numberToAlgorithm(v); result != nil {
			return *result, nil
		}
	case float32:
		if result := numberToAlgorithm(v); result != nil {
			return *result, nil
		}
	case float64:
		if result := numberToAlgorithm(v); result != nil {
			return *result, nil
		}
	default:
		return invalidAlgorithm, fmt.Errorf("invalid type %T", input)
	}
	return invalidAlgorithm, fmt.Errorf("%w: invalid value %v", ErrParseAlgorithm, input)
}

// algorithmsNameMap is a map of enum values to their Algorithm representation
// It is used to convert string representations of enum values into their Algorithm representation.
var algorithmsNameMap = map[string]Algorithm{
	"None":     Algorithms.NONE,
	"AES256":   Algorithms.AES256,
	"ChaCha20": Algorithms.CHACHA20,
}

// stringToAlgorithm converts a string representation of an enum value into its Algorithm representation
// It returns a pointer to the Algorithm representation of the enum value if the string is valid
// Otherwise, it returns nil
func stringToAlgorithm(s string) *Algorithm {
	if t, ok := algorithmsNameMap[s]; ok {
		return &t
	}
	return nil
}

// numberToAlgorithm converts a numeric value to a Algorithm
// It returns a pointer to the Algorithm representation of the enum value if the numeric value is valid
// Otherwise, it returns nil
func numberToAlgorithm[T number](num T) *Algorithm {
	f := float64(num)
	if math.Floor(f) != f {
		return nil
	}
	i := int(f)
	if i <= 0 || i > len(Algorithms.allSlice()) {
		return nil
	}
	result := Algorithms.allSlice()[i-1]
	if !result.IsValid() {
		return nil
	}
	return &result
}

// ExhaustiveAlgorithms iterates over all enum values and calls the provided function for each value.
// This function is useful for performing operations on all valid enum values in a loop.
func ExhaustiveAlgorithms(f func(Algorithm)) {
	for _, p := range Algorithms.allSlice() {
		f(p)
	}
}

// validAlgorithms is a map of enum values to their validity
var validAlgorithms = map[Algorithm]bool{
	Algorithms.NONE:     false,
	Algorithms.AES256:   true,
	Algorithms.CHACHA20: true,
}

// IsValid checks whether the Algorithms value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (a Algorithm) IsValid() bool {
	return validAlgorithms[a]
}

// MarshalJSON implements the json.Marshaler interface for Algorithm.
// It returns the JSON representation of the enum value as a byte slice.
func (a Algorithm) MarshalJSON() ([]byte, error) {
	return []byte("\"" + a.String() + "\""), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface for Algorithm.
// It parses the JSON representation of the enum value from the byte slice.
// It returns an error if the input is not a valid JSON representation.
func (a *Algorithm) UnmarshalJSON(b []byte) error {
	b = bytes.Trim(bytes.Trim(b, "\""), "\"")
	newa, err := ParseAlgorithm(b)
	if err != nil {
		return err
	}
	*a = newa
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for Algorithm.
// It returns the string representation of the enum value as a byte slice
func (a Algorithm) MarshalText() ([]byte, error) {
	return []byte("\"" + a.String() + "\""), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Algorithm.
// It parses the string representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (a *Algorithm) UnmarshalText(b []byte) error {
	newa, err := ParseAlgorithm(b)
	if err != nil {
		return err
	}
	*a = newa
	return nil
}

// Scan implements the database/sql.Scanner interface for Algorithm.
// It parses the string representation of the enum value from the database row.
// It returns an error if the row does not contain a valid enum value.
func (a *Algorithm) Scan(value any) error {
	newa, err := ParseAlgorithm(value)
	if err != nil {
		return err
	}
	*a = newa
	return nil
}

// Value implements the database/sql/driver.Valuer interface for Algorithm.
// It returns the string representation of the enum value.
func (a Algorithm) Value() (driver.Value, error) {
	return a.String(), nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for Algorithm.
// It returns the binary representation of the enum value as a byte slice.
func (a Algorithm) MarshalBinary() ([]byte, error) {
	return []byte("\"" + a.String() + "\""), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for Algorithm.
// It parses the binary representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (a *Algorithm) UnmarshalBinary(b []byte) error {
	newa, err := ParseAlgorithm(b)
	if err != nil {
		return err
	}
	*a = newa
	return nil
}

// MarshalYAML implements the yaml.Marshaler interface for Algorithm.
// It returns the string representation of the enum value.
func (a Algorithm) MarshalYAML() ([]byte, error) {
	return []byte(a.String()), nil
}

// UnmarshalYAML implements the yaml.Unmarshaler interface for Planet.
// It parses the byte slice representation of the enum value and returns an error
// if the YAML byte slice does not contain a valid enum value.
func (a *Algorithm) UnmarshalYAML(b []byte) error {
	newa, err := ParseAlgorithm(b)
	if err != nil {
		return err
	}
	*a = newa
	return nil
}

type float interface {
	float32 | float64
}
type integer interface {
	int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | uintptr
}
type number interface {
	integer | float
}

// algorithmNames is a constant string slice containing all enum values cononical absolute names
const algorithmNames = "NoneAES256ChaCha20"

// algorithmNamesMap is a map of enum values to their canonical absolute
// name positions within the algorithmNames string slice
var algorithmNamesMap = map[Algorithm]string{
	Algorithms.NONE:     algorithmNames[0:4],
	Algorithms.AES256:   algorithmNames[4:10],
	Algorithms.CHACHA20: algorithmNames[10:18],
}

// String implements the Stringer interface.
// It returns the canonical absolute name of the enum value.
func (a Algorithm) String() string {
	if str, ok := algorithmNamesMap[a]; ok {
		return str
	}
	return fmt.Sprintf("algorithm(%d)", a.algorithm)
}

// Compile-time check that all enum values are valid.
// This function is used to ensure that all enum values are defined and valid.
// It is called by the compiler to verify that the enum values are valid.
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [2]struct{}
	_ = x[None+1]
	_ = x[AES256]
	_ = x[ChaCha20-1]
}
