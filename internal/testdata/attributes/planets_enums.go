// DO NOT EDIT.
// code generated by goenums 'v0.3.8' at 2025-05-04 00:40:37.
// github.com/zarldev/goenums
//
// using the command:
//
// goenums planets.go

package planets

import (
	"bytes"
	"database/sql/driver"
	"fmt"
	"iter"
	"strconv"
)

type Planet struct {
	planet
	Gravity             float64
	RadiusKm            float64
	MassKg              float64
	OrbitKm             float64
	OrbitDays           float64
	SurfacePressureBars float64
	Moons               int
	Rings               bool
}

type planetsContainer struct {
	UNKNOWN Planet
	MERCURY Planet
	VENUS   Planet
	EARTH   Planet
	MARS    Planet
	JUPITER Planet
	SATURN  Planet
	URANUS  Planet
	NEPTUNE Planet
}

var Planets = planetsContainer{
	MERCURY: Planet{
		planet:              mercury,
		Gravity:             0.378000,
		RadiusKm:            2439.700000,
		MassKg:              330000000000000029360128.000000,
		OrbitKm:             57910000.000000,
		OrbitDays:           88.000000,
		SurfacePressureBars: 0.000000,
		Moons:               0,
		Rings:               false,
	},
	VENUS: Planet{
		planet:              venus,
		Gravity:             0.907000,
		RadiusKm:            6051.800000,
		MassKg:              4869999999999999601541120.000000,
		OrbitKm:             108200000.000000,
		OrbitDays:           225.000000,
		SurfacePressureBars: 92.000000,
		Moons:               0,
		Rings:               false,
	},
	EARTH: Planet{
		planet:              earth,
		Gravity:             1.000000,
		RadiusKm:            6378.100000,
		MassKg:              5970000000000000281018368.000000,
		OrbitKm:             149600000.000000,
		OrbitDays:           365.000000,
		SurfacePressureBars: 1.000000,
		Moons:               1,
		Rings:               false,
	},
	MARS: Planet{
		planet:              mars,
		Gravity:             0.377000,
		RadiusKm:            3389.500000,
		MassKg:              642000000000000046137344.000000,
		OrbitKm:             227900000.000000,
		OrbitDays:           687.000000,
		SurfacePressureBars: 0.010000,
		Moons:               2,
		Rings:               false,
	},
	JUPITER: Planet{
		planet:              jupiter,
		Gravity:             2.360000,
		RadiusKm:            69911.000000,
		MassKg:              1900000000000000107709726720.000000,
		OrbitKm:             778600000.000000,
		OrbitDays:           4333.000000,
		SurfacePressureBars: 20.000000,
		Moons:               4,
		Rings:               true,
	},
	SATURN: Planet{
		planet:              saturn,
		Gravity:             0.916000,
		RadiusKm:            58232.000000,
		MassKg:              568000000000000011945377792.000000,
		OrbitKm:             1433500000.000000,
		OrbitDays:           10759.000000,
		SurfacePressureBars: 1.000000,
		Moons:               7,
		Rings:               true,
	},
	URANUS: Planet{
		planet:              uranus,
		Gravity:             0.889000,
		RadiusKm:            25362.000000,
		MassKg:              86800000000000000905969664.000000,
		OrbitKm:             2872500000.000000,
		OrbitDays:           30687.000000,
		SurfacePressureBars: 1.300000,
		Moons:               13,
		Rings:               true,
	},
	NEPTUNE: Planet{
		planet:              neptune,
		Gravity:             1.120000,
		RadiusKm:            24622.000000,
		MassKg:              102000000000000007952400384.000000,
		OrbitKm:             4495100000.000000,
		OrbitDays:           60190.000000,
		SurfacePressureBars: 1.500000,
		Moons:               2,
		Rings:               true,
	},
}

// invalidPlanet represents an invalid or undefined Planet value.
// It is used as a default return value for failed parsing or conversion operations.
var invalidPlanet = Planet{}

// allSlice is an internal method that returns all valid Planet values as a slice.
func (c planetsContainer) allSlice() []Planet {
	return []Planet{
		c.MERCURY,
		c.VENUS,
		c.EARTH,
		c.MARS,
		c.JUPITER,
		c.SATURN,
		c.URANUS,
		c.NEPTUNE,
	}
}

// AllSlice returns all valid Planet values as a slice.
func (c planetsContainer) AllSlice() []Planet {
	return c.allSlice()
}

// All returns all valid Planet values.
// In Go 1.23+, this can be used with range-over-function iteration:
// ```
//
//	for v := range Planets.All() {
//	    // process each enum value
//	}
//
// ```
func (c planetsContainer) All() iter.Seq[Planet] {
	return func(yield func(Planet) bool) {
		for _, v := range c.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// ParsePlanet converts various input types to a Planet value.
// It accepts the following types:
// - Planet: returns the value directly
// - string: parses the string representation
// - []byte: converts to string and parses
// - fmt.Stringer: uses the String() result for parsing
// - int/int32/int64: converts the integer to the corresponding enum value
//
// If the input cannot be converted to a valid Planet value, it returns
// the invalidPlanet value without an error.
func ParsePlanet(a any) (Planet, error) {
	res := invalidPlanet
	switch v := a.(type) {
	case Planet:
		return v, nil
	case []byte:
		res = stringToPlanet(string(v))
	case string:
		res = stringToPlanet(v)
	case fmt.Stringer:
		res = stringToPlanet(v.String())
	case int:
		res = intToPlanet(v)
	case int64:
		res = intToPlanet(int(v))
	case int32:
		res = intToPlanet(int(v))
	}
	return res, nil
}

// stringToPlanet is an internal function that converts a string to a Planet value.
// It uses a predefined mapping of string representations to enum values.
var (
	planetsNameMap = map[string]Planet{
		"unknown": Planets.UNKNOWN, // primary alias
		"Mercury": Planets.MERCURY, // primary alias
		"mercury": Planets.MERCURY, // enum name
		"Venus":   Planets.VENUS,   // primary alias
		"venus":   Planets.VENUS,   // enum name
		"Earth":   Planets.EARTH,   // primary alias
		"earth":   Planets.EARTH,   // enum name
		"Mars":    Planets.MARS,    // primary alias
		"mars":    Planets.MARS,    // enum name
		"Jupiter": Planets.JUPITER, // primary alias
		"jupiter": Planets.JUPITER, // enum name
		"Saturn":  Planets.SATURN,  // primary alias
		"saturn":  Planets.SATURN,  // enum name
		"Uranus":  Planets.URANUS,  // primary alias
		"uranus":  Planets.URANUS,  // enum name
		"Neptune": Planets.NEPTUNE, // primary alias
		"neptune": Planets.NEPTUNE, // enum name
	}
)

func stringToPlanet(s string) Planet {
	if v, ok := planetsNameMap[s]; ok {
		return v
	}
	return invalidPlanet
}

// intToPlanet converts an integer to a Planet value.
// The integer is treated as the ordinal position in the enum sequence.
// The input is adjusted by -9 to account for the enum starting value.
// If the integer doesn't correspond to a valid enum value, invalidPlanet is returned.
func intToPlanet(i int) Planet {
	i -= 9
	if i < 0 || i >= len(Planets.allSlice()) {
		return invalidPlanet
	}
	return Planets.allSlice()[i]
}

// ExhaustivePlanets calls the provided function once for each valid Planets value.
// This is useful for switch statement exhaustiveness checking and for processing all enum values.
// Example usage:
// ```
//
//	ExhaustivePlanets(func(x Planet) {
//	    switch x {
//	    case Planets.Neptune:
//	        // handle Neptune
//	    }
//	})
//
// ```
func ExhaustivePlanets(f func(Planet)) {
	for _, p := range Planets.allSlice() {
		f(p)
	}
}

// validPlanets is a map of valid Planet values.
var validPlanets = map[Planet]bool{
	Planets.MERCURY: true,
	Planets.VENUS:   true,
	Planets.EARTH:   true,
	Planets.MARS:    true,
	Planets.JUPITER: true,
	Planets.SATURN:  true,
	Planets.URANUS:  true,
	Planets.NEPTUNE: true,
}

// IsValid checks whether the Planet value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (p Planet) IsValid() bool {
	return validPlanets[p]
}

// MarshalJSON implements the json.Marshaler interface for Planet.
// The enum value is encoded as its string representation.
func (p Planet) MarshalJSON() ([]byte, error) {
	return []byte(`"` + p.String() + `"`), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface for Planet.
// It supports unmarshaling from a string representation of the enum.
func (p *Planet) UnmarshalJSON(b []byte) error {
	b = bytes.Trim(bytes.Trim(b, `"`), ` `)
	newp, err := ParsePlanet(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// Scan implements the sql.Scanner interface for Planet.
// This allows Planet values to be scanned directly from database queries.
// It supports scanning from strings, []byte, or integers.
func (p *Planet) Scan(value any) error {
	newp, err := ParsePlanet(value)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// Value implements the driver.Valuer interface for Planet.
// This allows Planet values to be saved to databases.
// The value is stored as a string representation of the enum.
func (p Planet) Value() (driver.Value, error) {
	return p.String(), nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for Planet.
// It encodes the enum value as a byte slice.
func (p Planet) MarshalBinary() ([]byte, error) {
	return []byte(p.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for Planet.
// It decodes the enum value from a byte slice.
func (p *Planet) UnmarshalBinary(b []byte) error {
	newp, err := ParsePlanet(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for Planet.
// The enum value is encoded as its string representation.
func (p Planet) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Planet.
// It supports unmarshaling from a string representation of the enum.
func (p *Planet) UnmarshalText(b []byte) error {
	newp, err := ParsePlanet(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [1]struct{}
	_ = x[unknown-0]
	_ = x[mercury-1]
	_ = x[venus-2]
	_ = x[earth-3]
	_ = x[mars-4]
	_ = x[jupiter-5]
	_ = x[saturn-6]
	_ = x[uranus-7]
	_ = x[neptune-8]
}

const planetsName = "unknownMercuryVenusEarthMarsJupiterSaturnUranusNeptune"

var planetsIdx = [...]uint16{0, 7, 14, 19, 24, 28, 35, 41, 47, 54}

// String returns the string representation of the Planet value.
// For valid values, it returns the name of the constant.
// For invalid values, it returns a string in the format "planets(N)",
// where N is the numeric value.
func (i planet) String() string {
	if i < 0 || i > planet(len(planetsIdx)-1)+-1 {
		return "planets(" + (strconv.FormatInt(int64(i), 10) + ")")
	}
	return planetsName[planetsIdx[i]:planetsIdx[i+1]]
}
