// DO NOT EDIT.
// code generated by goenums 'v0.3.8' at 2025-05-03 02:52:54.
// github.com/zarldev/goenums
//
// using the command:
//
// goenums tickets.go

package tickets

import (
	"bytes"
	"database/sql/driver"
	"fmt"
	"iter"
	"strconv"
)

type Ticket struct {
	ticket
	comment    string
	validstate bool
}

type ticketsContainer struct {
	UNKNOWN           Ticket
	CREATED           Ticket
	PENDING           Ticket
	APPROVAL_PENDING  Ticket
	APPROVAL_ACCEPTED Ticket
	REJECTED          Ticket
	COMPLETED         Ticket
}

var Tickets = ticketsContainer{
	CREATED: Ticket{
		ticket:     created,
		comment:    "\"Ticket created successfully\"",
		validstate: true,
	},
	PENDING: Ticket{
		ticket:     pending,
		comment:    "\"Ticket is being processed\"",
		validstate: true,
	},
	APPROVAL_PENDING: Ticket{
		ticket:     approval_pending,
		comment:    "\"Ticket is pending approval\"",
		validstate: true,
	},
	APPROVAL_ACCEPTED: Ticket{
		ticket:     approval_accepted,
		comment:    "\"Ticket has been fully approved\"",
		validstate: true,
	},
	REJECTED: Ticket{
		ticket:     rejected,
		comment:    "\"Ticket has been rejected\"",
		validstate: false,
	},
	COMPLETED: Ticket{
		ticket:     completed,
		comment:    "\"Ticket has been completed\"",
		validstate: false,
	},
}

// invalidTicket represents an invalid or undefined Ticket value.
// It is used as a default return value for failed parsing or conversion operations.
var invalidTicket = Ticket{}

// allSlice is an internal method that returns all valid Ticket values as a slice.
func (c ticketsContainer) allSlice() []Ticket {
	return []Ticket{
		c.CREATED,
		c.PENDING,
		c.APPROVAL_PENDING,
		c.APPROVAL_ACCEPTED,
		c.REJECTED,
		c.COMPLETED,
	}
}

// AllSlice returns all valid Ticket values as a slice.
func (c ticketsContainer) AllSlice() []Ticket {
	return c.allSlice()
}

// All returns all valid Ticket values.
// In Go 1.23+, this can be used with range-over-function iteration:
// ```
//
//	for v := range Tickets.All() {
//	    // process each enum value
//	}
//
// ```
func (c ticketsContainer) All() iter.Seq[Ticket] {
	return func(yield func(Ticket) bool) {
		for _, v := range c.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// ParseTicket converts various input types to a Ticket value.
// It accepts the following types:
// - Ticket: returns the value directly
// - string: parses the string representation
// - []byte: converts to string and parses
// - fmt.Stringer: uses the String() result for parsing
// - int/int32/int64: converts the integer to the corresponding enum value
//
// If the input cannot be converted to a valid Ticket value, it returns
// the invalidTicket value without an error.
func ParseTicket(a any) (Ticket, error) {
	res := invalidTicket
	switch v := a.(type) {
	case Ticket:
		return v, nil
	case []byte:
		res = stringToTicket(string(v))
	case string:
		res = stringToTicket(v)
	case fmt.Stringer:
		res = stringToTicket(v.String())
	case int:
		res = intToTicket(v)
	case int64:
		res = intToTicket(int(v))
	case int32:
		res = intToTicket(int(v))
	}
	return res, nil
}

// stringToTicket is an internal function that converts a string to a Ticket value.
// It uses a predefined mapping of string representations to enum values.
var (
	ticketsNameMap = map[string]Ticket{
		"\"Not Found\"":              Tickets.UNKNOWN,           // primary alias
		"\"Missing\"":                Tickets.UNKNOWN,           // additional alias
		"unknown":                    Tickets.UNKNOWN,           // enum name
		"\"Created Successfully\"":   Tickets.CREATED,           // primary alias
		"\"Created\"":                Tickets.CREATED,           // additional alias
		"created":                    Tickets.CREATED,           // enum name
		"\"In Progress\"":            Tickets.PENDING,           // primary alias
		"\"Pending\"":                Tickets.PENDING,           // additional alias
		"pending":                    Tickets.PENDING,           // enum name
		"\"Pending Approval\"":       Tickets.APPROVAL_PENDING,  // primary alias
		"\"Approval Pending\"":       Tickets.APPROVAL_PENDING,  // additional alias
		"approval_pending":           Tickets.APPROVAL_PENDING,  // enum name
		"\"Fully Approved\"":         Tickets.APPROVAL_ACCEPTED, // primary alias
		"\"Approval Accepted\"":      Tickets.APPROVAL_ACCEPTED, // additional alias
		"approval_accepted":          Tickets.APPROVAL_ACCEPTED, // enum name
		"\"Has Been Rejected\"":      Tickets.REJECTED,          // primary alias
		"\"Rejected\"":               Tickets.REJECTED,          // additional alias
		"rejected":                   Tickets.REJECTED,          // enum name
		"\"Successfully Completed\"": Tickets.COMPLETED,         // primary alias
		"\"Completed\"":              Tickets.COMPLETED,         // additional alias
		"completed":                  Tickets.COMPLETED,         // enum name
	}
)

func stringToTicket(s string) Ticket {
	if v, ok := ticketsNameMap[s]; ok {
		return v
	}
	return invalidTicket
}

// intToTicket converts an integer to a Ticket value.
// The integer is treated as the ordinal position in the enum sequence.
// The input is adjusted by -7 to account for the enum starting value.
// If the integer doesn't correspond to a valid enum value, invalidTicket is returned.
func intToTicket(i int) Ticket {
	i -= 7
	if i < 0 || i >= len(Tickets.allSlice()) {
		return invalidTicket
	}
	return Tickets.allSlice()[i]
}

// ExhaustiveTickets calls the provided function once for each valid Tickets value.
// This is useful for switch statement exhaustiveness checking and for processing all enum values.
// Example usage:
// ```
//
//	ExhaustiveTickets(func(x Ticket) {
//	    switch x {
//	    case Tickets.Completed:
//	        // handle Completed
//	    }
//	})
//
// ```
func ExhaustiveTickets(f func(Ticket)) {
	for _, p := range Tickets.allSlice() {
		f(p)
	}
}

// validTickets is a map of valid Ticket values.
var validTickets = map[Ticket]bool{
	Tickets.CREATED:           true,
	Tickets.PENDING:           true,
	Tickets.APPROVAL_PENDING:  true,
	Tickets.APPROVAL_ACCEPTED: true,
	Tickets.REJECTED:          true,
	Tickets.COMPLETED:         true,
}

// IsValid checks whether the Ticket value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (p Ticket) IsValid() bool {
	return validTickets[p]
}

// MarshalJSON implements the json.Marshaler interface for Ticket.
// The enum value is encoded as its string representation.
func (p Ticket) MarshalJSON() ([]byte, error) {
	return []byte(`"` + p.String() + `"`), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface for Ticket.
// It supports unmarshaling from a string representation of the enum.
func (p *Ticket) UnmarshalJSON(b []byte) error {
	b = bytes.Trim(bytes.Trim(b, `"`), ` `)
	newp, err := ParseTicket(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// Scan implements the sql.Scanner interface for Ticket.
// This allows Ticket values to be scanned directly from database queries.
// It supports scanning from strings, []byte, or integers.
func (p *Ticket) Scan(value any) error {
	newp, err := ParseTicket(value)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// Value implements the driver.Valuer interface for Ticket.
// This allows Ticket values to be saved to databases.
// The value is stored as a string representation of the enum.
func (p Ticket) Value() (driver.Value, error) {
	return p.String(), nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for Ticket.
// It encodes the enum value as a byte slice.
func (p Ticket) MarshalBinary() ([]byte, error) {
	return []byte(p.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for Ticket.
// It decodes the enum value from a byte slice.
func (p *Ticket) UnmarshalBinary(b []byte) error {
	newp, err := ParseTicket(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for Ticket.
// The enum value is encoded as its string representation.
func (p Ticket) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Ticket.
// It supports unmarshaling from a string representation of the enum.
func (p *Ticket) UnmarshalText(b []byte) error {
	newp, err := ParseTicket(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [1]struct{}
	_ = x[unknown-0]
	_ = x[created-1]
	_ = x[pending-2]
	_ = x[approval_pending-3]
	_ = x[approval_accepted-4]
	_ = x[rejected-5]
	_ = x[completed-6]
}

const ticketsName = "\"Not Found\"\"Created Successfully\"\"In Progress\"\"Pending Approval\"\"Fully Approved\"\"Has Been Rejected\"\"Successfully Completed\""

var ticketsIdx = [...]uint16{0, 11, 33, 46, 64, 80, 99, 123}

// String returns the string representation of the Ticket value.
// For valid values, it returns the name of the constant.
// For invalid values, it returns a string in the format "tickets(N)",
// where N is the numeric value.
func (i ticket) String() string {
	if i < 0 || i > ticket(len(ticketsIdx)-1)+-1 {
		return "tickets(" + (strconv.FormatInt(int64(i), 10) + ")")
	}
	return ticketsName[ticketsIdx[i]:ticketsIdx[i+1]]
}
