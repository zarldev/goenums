// code generated by goenums 'v0.4.0' at Jun  3 00:14:40. DO NOT EDIT.
//
// github.com/zarldev/goenums
//
// using the command:
// goenums goenums tickets.gotickets.go

package tickets

import (
	"bytes"
	"context"
	"database/sql/driver"
	"fmt"
	"iter"
	"math"

	"golang.org/x/exp/constraints"
)

// Ticket is a type that represents a single enum value.
// It combines the core information about the enum constant and it's defined fields.
type Ticket struct {
	ticket
	comment    string
	validstate bool
}

// ticketsContainer is the container for all enum values.
// It is private and should not be used directly use the public methods on the Ticket type.
type ticketsContainer struct {
	UNKNOWN           Ticket
	CREATED           Ticket
	PENDING           Ticket
	APPROVAL_PENDING  Ticket
	APPROVAL_ACCEPTED Ticket
	REJECTED          Ticket
	COMPLETED         Ticket
}

// Tickets is a main entry point using the Ticket type.
// It it a container for all enum values and provides a convenient way to access all enum values and perform
// operations, with convenience methods for common use cases.
var Tickets = ticketsContainer{
	UNKNOWN: Ticket{
		ticket:     unknown,
		comment:    "Ticket not found",
		validstate: false,
	},
	CREATED: Ticket{
		ticket:     created,
		comment:    "Ticket created successfully",
		validstate: true,
	},
	PENDING: Ticket{
		ticket:     pending,
		comment:    "Ticket is being processed",
		validstate: true,
	},
	APPROVAL_PENDING: Ticket{
		ticket:     approval_pending,
		comment:    "Ticket is pending approval",
		validstate: true,
	},
	APPROVAL_ACCEPTED: Ticket{
		ticket:     approval_accepted,
		comment:    "Ticket has been fully approved",
		validstate: true,
	},
	REJECTED: Ticket{
		ticket:     rejected,
		comment:    "Ticket has been rejected",
		validstate: false,
	},
	COMPLETED: Ticket{
		ticket:     completed,
		comment:    "Ticket has been completed",
		validstate: false,
	},
}

// invalidTicket is an invalid sentinel value for Ticket
var invalidTicket = Ticket{}

// allSlice returns a slice of all enum values.
// This method is useful for iterating over all enum values in a loop.
func (t ticketsContainer) allSlice() []Ticket {
	return []Ticket{
		Tickets.UNKNOWN,
		Tickets.CREATED,
		Tickets.PENDING,
		Tickets.APPROVAL_PENDING,
		Tickets.APPROVAL_ACCEPTED,
		Tickets.REJECTED,
		Tickets.COMPLETED,
	}
}

// All returns an iterator over all enum values.
// This method is useful for iterating over all enum values in a loop.
func (t ticketsContainer) All() iter.Seq[Ticket] {
	return func(yield func(Ticket) bool) {
		for _, v := range t.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// ParseTicket parses the input value into an enum value.
// It returns the parsed enum value or an error if the input is invalid.
// It is a convenience function that can be used to parse enum values from
// various input types, such as strings, byte slices, or other enum types.
func ParseTicket(input any) (Ticket, error) {
	var res = invalidTicket
	switch v := input.(type) {
	case Ticket:
		return v, nil
	case string:
		res = stringToTicket(v)
	case fmt.Stringer:
		res = stringToTicket(v.String())
	case []byte:
		res = stringToTicket(string(v))
	case int:
		res = numberToTicket(v)
	case int8:
		res = numberToTicket(v)
	case int16:
		res = numberToTicket(v)
	case int32:
		res = numberToTicket(v)
	case int64:
		res = numberToTicket(v)
	case uint:
		res = numberToTicket(v)
	case uint8:
		res = numberToTicket(v)
	case uint16:
		res = numberToTicket(v)
	case uint32:
		res = numberToTicket(v)
	case uint64:
		res = numberToTicket(v)
	case float32:
		res = numberToTicket(v)
	case float64:
		res = numberToTicket(v)
	default:
		return res, fmt.Errorf("invalid type %T", input)
	}
	return res, nil
}

// ticketsNameMap is a map of enum values to their Ticket representation
// It is used to convert string representations of enum values into their Ticket representation.
var ticketsNameMap = map[string]Ticket{
	"Not Found":              Tickets.UNKNOWN,
	"Missing":                Tickets.UNKNOWN,
	"Created Successfully":   Tickets.CREATED,
	"Created":                Tickets.CREATED,
	"In Progress":            Tickets.PENDING,
	"Pending":                Tickets.PENDING,
	"Pending Approval":       Tickets.APPROVAL_PENDING,
	"Approval Pending":       Tickets.APPROVAL_PENDING,
	"Fully Approved":         Tickets.APPROVAL_ACCEPTED,
	"Approval Accepted":      Tickets.APPROVAL_ACCEPTED,
	"Has Been Rejected":      Tickets.REJECTED,
	"Rejected":               Tickets.REJECTED,
	"Successfully Completed": Tickets.COMPLETED,
	"Completed":              Tickets.COMPLETED,
}

// stringToTicket converts a string representation of an enum value into its Ticket representation
// It returns the Ticket representation of the enum value if the string is valid
// Otherwise, it returns invalidTicket
func stringToTicket(s string) Ticket {
	if t, ok := ticketsNameMap[s]; ok {
		return t
	}
	return invalidTicket
}

// numberToTicket converts a numeric value to a Ticket
// It returns the Ticket representation of the enum value if the numeric value is valid
// Otherwise, it returns invalidTicket
func numberToTicket[T constraints.Integer | constraints.Float](num T) Ticket {
	f := float64(num)
	if math.Floor(f) != f {
		return invalidTicket
	}
	i := int(f)
	if i <= 0 || i > len(Tickets.allSlice()) {
		return invalidTicket
	}
	return Tickets.allSlice()[i]
}

// ExhaustiveTickets iterates over all enum values and calls the provided function for each value.
// This function is useful for performing operations on all valid enum values in a loop.
func ExhaustiveTickets(f func(Ticket)) {
	for _, p := range Tickets.allSlice() {
		f(p)
	}
}

// validTickets is a map of enum values to their validity
var validTickets = map[Ticket]bool{
	Tickets.UNKNOWN:           false,
	Tickets.CREATED:           true,
	Tickets.PENDING:           true,
	Tickets.APPROVAL_PENDING:  true,
	Tickets.APPROVAL_ACCEPTED: true,
	Tickets.REJECTED:          true,
	Tickets.COMPLETED:         true,
}

// IsValid checks whether the Tickets value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (t Ticket) IsValid() bool {
	return validTickets[t]
}

// MarshalJSON implements the json.Marshaler interface for Ticket.
// It returns the JSON representation of the enum value as a byte slice.
func (t Ticket) MarshalJSON() ([]byte, error) {
	return []byte("\"" + t.String() + "\""), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface for Ticket.
// It parses the JSON representation of the enum value from the byte slice.
// It returns an error if the input is not a valid JSON representation.
func (t *Ticket) UnmarshalJSON(b []byte) error {
	b = bytes.Trim(bytes.Trim(b, "\""), "\"")
	newt, err := ParseTicket(b)
	if err != nil {
		return err
	}
	*t = newt
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for Ticket.
// It returns the string representation of the enum value as a byte slice
func (t Ticket) MarshalText() ([]byte, error) {
	return []byte("\"" + t.String() + "\""), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Ticket.
// It parses the string representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (t *Ticket) UnmarshalText(b []byte) error {
	newt, err := ParseTicket(b)
	if err != nil {
		return err
	}
	*t = newt
	return nil
}

// Scan implements the database/sql.Scanner interface for Ticket.
// It parses the string representation of the enum value from the database row.
// It returns an error if the row does not contain a valid enum value.
func (t *Ticket) Scan(value any) error {
	newt, err := ParseTicket(value)
	if err != nil {
		return err
	}
	*t = newt
	return nil
}

// Value implements the database/sql/driver.Valuer interface for Ticket.
// It returns the string representation of the enum value.
func (t Ticket) Value() (driver.Value, error) {
	return t.String(), nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for Ticket.
// It returns the binary representation of the enum value as a byte slice.
func (t Ticket) MarshalBinary() ([]byte, error) {
	return []byte("\"" + t.String() + "\""), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for Ticket.
// It parses the binary representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (t *Ticket) UnmarshalBinary(b []byte) error {
	newt, err := ParseTicket(b)
	if err != nil {
		return err
	}
	*t = newt
	return nil
}

// MarshalYAML implements the yaml.Marshaler interface for Ticket.
// It returns the string representation of the enum value.
// It returns an error if the enum value is invalid.
func (t Ticket) MarshalYAML() (any, error) {
	return t.String(), nil
}

// UnmarshalYAML implements the yaml.Unmarshaler interface for Ticket.
// It parses the string representation of the enum value from the YAML node.
// It returns an error if the YAML node does not contain a valid enum value.
func (t *Ticket) UnmarshalYAML(ctx context.Context, f func(any) error) error {
	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
	}
	return f(t.String())
}

// ticketNames is a constant string slice containing all enum values cononical absolute names
const ticketNames = "Not FoundCreated SuccessfullyIn ProgressPending ApprovalFully ApprovedHas Been RejectedSuccessfully Completed"

// ticketNamesMap is a map of enum values to their canonical absolute
// name positions within the ticketNames string slice
var ticketNamesMap = map[Ticket]string{
	Tickets.UNKNOWN:           ticketNames[0:9],
	Tickets.CREATED:           ticketNames[9:29],
	Tickets.PENDING:           ticketNames[29:40],
	Tickets.APPROVAL_PENDING:  ticketNames[40:56],
	Tickets.APPROVAL_ACCEPTED: ticketNames[56:70],
	Tickets.REJECTED:          ticketNames[70:87],
	Tickets.COMPLETED:         ticketNames[87:109],
}

// String implements the Stringer interface.
// It returns the canonical absolute name of the enum value.
func (t Ticket) String() string {
	if str, ok := ticketNamesMap[t]; ok {
		return str
	}
	return fmt.Sprintf("ticket(%d)", t.ticket)
}

// Compile-time check that all enum values are valid.
// This function is used to ensure that all enum values are defined and valid.
// It is called by the compiler to verify that the enum values are valid.
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [7]struct{}
	_ = x[unknown-0]
	_ = x[created-1]
	_ = x[pending-2]
	_ = x[approval_pending-3]
	_ = x[approval_accepted-4]
	_ = x[rejected-5]
	_ = x[completed-6]
}
