// code generated by goenums v0.4.0 at Jun  3 01:58:16. DO NOT EDIT.
//
// github.com/zarldev/goenums
//
// using the command:
// goenums goenums multiple.gomultiple.go

package multipleenums

import (
	"bytes"
	"context"
	"database/sql/driver"
	"fmt"
	"iter"
	"math"

	"golang.org/x/exp/constraints"
)

// Order is a type that represents a single enum value.
// It combines the core information about the enum constant and it's defined fields.
type Order struct {
	order
}

// ordersContainer is the container for all enum values.
// It is private and should not be used directly use the public methods on the Order type.
type ordersContainer struct {
	CREATED     Order
	APPROVED    Order
	PROCESSING  Order
	READYTOSHIP Order
	SHIPPED     Order
	DELIVERED   Order
	CANCELLED   Order
	PASSED      Order
	SKIPPED     Order
	SCHEDULED   Order
	RUNNING     Order
	BOOKED      Order
}

// Orders is a main entry point using the Order type.
// It it a container for all enum values and provides a convenient way to access all enum values and perform
// operations, with convenience methods for common use cases.
var Orders = ordersContainer{
	CREATED: Order{
		order: created,
	},
	APPROVED: Order{
		order: approved,
	},
	PROCESSING: Order{
		order: processing,
	},
	READYTOSHIP: Order{
		order: readyToShip,
	},
	SHIPPED: Order{
		order: shipped,
	},
	DELIVERED: Order{
		order: delivered,
	},
	CANCELLED: Order{
		order: cancelled,
	},
	PASSED: Order{
		order: passed,
	},
	SKIPPED: Order{
		order: skipped,
	},
	SCHEDULED: Order{
		order: scheduled,
	},
	RUNNING: Order{
		order: running,
	},
	BOOKED: Order{
		order: booked,
	},
}

// invalidOrder is an invalid sentinel value for Order
var invalidOrder = Order{}

// allSlice returns a slice of all enum values.
// This method is useful for iterating over all enum values in a loop.
func (o ordersContainer) allSlice() []Order {
	return []Order{
		Orders.CREATED,
		Orders.APPROVED,
		Orders.PROCESSING,
		Orders.READYTOSHIP,
		Orders.SHIPPED,
		Orders.DELIVERED,
		Orders.CANCELLED,
		Orders.PASSED,
		Orders.SKIPPED,
		Orders.SCHEDULED,
		Orders.RUNNING,
		Orders.BOOKED,
	}
}

// All returns an iterator over all enum values.
// This method is useful for iterating over all enum values in a loop.
func (o ordersContainer) All() iter.Seq[Order] {
	return func(yield func(Order) bool) {
		for _, v := range o.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// ParseOrder parses the input value into an enum value.
// It returns the parsed enum value or an error if the input is invalid.
// It is a convenience function that can be used to parse enum values from
// various input types, such as strings, byte slices, or other enum types.
func ParseOrder(input any) (Order, error) {
	var res = invalidOrder
	switch v := input.(type) {
	case Order:
		return v, nil
	case string:
		res = stringToOrder(v)
	case fmt.Stringer:
		res = stringToOrder(v.String())
	case []byte:
		res = stringToOrder(string(v))
	case int:
		res = numberToOrder(v)
	case int8:
		res = numberToOrder(v)
	case int16:
		res = numberToOrder(v)
	case int32:
		res = numberToOrder(v)
	case int64:
		res = numberToOrder(v)
	case uint:
		res = numberToOrder(v)
	case uint8:
		res = numberToOrder(v)
	case uint16:
		res = numberToOrder(v)
	case uint32:
		res = numberToOrder(v)
	case uint64:
		res = numberToOrder(v)
	case float32:
		res = numberToOrder(v)
	case float64:
		res = numberToOrder(v)
	default:
		return res, fmt.Errorf("invalid type %T", input)
	}
	return res, nil
}

// ordersNameMap is a map of enum values to their Order representation
// It is used to convert string representations of enum values into their Order representation.
var ordersNameMap = map[string]Order{
	"CREATED":       Orders.CREATED,
	"APPROVED":      Orders.APPROVED,
	"PROCESSING":    Orders.PROCESSING,
	"READY_TO_SHIP": Orders.READYTOSHIP,
	"SHIPPED":       Orders.SHIPPED,
	"DELIVERED":     Orders.DELIVERED,
	"CANCELLED":     Orders.CANCELLED,
	"PASSED":        Orders.PASSED,
	"SKIPPED":       Orders.SKIPPED,
	"SCHEDULED":     Orders.SCHEDULED,
	"RUNNING":       Orders.RUNNING,
	"BOOKED":        Orders.BOOKED,
}

// stringToOrder converts a string representation of an enum value into its Order representation
// It returns the Order representation of the enum value if the string is valid
// Otherwise, it returns invalidOrder
func stringToOrder(s string) Order {
	if t, ok := ordersNameMap[s]; ok {
		return t
	}
	return invalidOrder
}

// numberToOrder converts a numeric value to a Order
// It returns the Order representation of the enum value if the numeric value is valid
// Otherwise, it returns invalidOrder
func numberToOrder[T constraints.Integer | constraints.Float](num T) Order {
	f := float64(num)
	if math.Floor(f) != f {
		return invalidOrder
	}
	i := int(f)
	if i <= 0 || i > len(Orders.allSlice()) {
		return invalidOrder
	}
	return Orders.allSlice()[i]
}

// ExhaustiveOrders iterates over all enum values and calls the provided function for each value.
// This function is useful for performing operations on all valid enum values in a loop.
func ExhaustiveOrders(f func(Order)) {
	for _, p := range Orders.allSlice() {
		f(p)
	}
}

// validOrders is a map of enum values to their validity
var validOrders = map[Order]bool{
	Orders.CREATED:     true,
	Orders.APPROVED:    true,
	Orders.PROCESSING:  true,
	Orders.READYTOSHIP: true,
	Orders.SHIPPED:     true,
	Orders.DELIVERED:   true,
	Orders.CANCELLED:   true,
	Orders.PASSED:      true,
	Orders.SKIPPED:     true,
	Orders.SCHEDULED:   true,
	Orders.RUNNING:     true,
	Orders.BOOKED:      true,
}

// IsValid checks whether the Orders value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (o Order) IsValid() bool {
	return validOrders[o]
}

// MarshalJSON implements the json.Marshaler interface for Order.
// It returns the JSON representation of the enum value as a byte slice.
func (o Order) MarshalJSON() ([]byte, error) {
	return []byte("\"" + o.String() + "\""), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface for Order.
// It parses the JSON representation of the enum value from the byte slice.
// It returns an error if the input is not a valid JSON representation.
func (o *Order) UnmarshalJSON(b []byte) error {
	b = bytes.Trim(bytes.Trim(b, "\""), "\"")
	newo, err := ParseOrder(b)
	if err != nil {
		return err
	}
	*o = newo
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for Order.
// It returns the string representation of the enum value as a byte slice
func (o Order) MarshalText() ([]byte, error) {
	return []byte("\"" + o.String() + "\""), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Order.
// It parses the string representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (o *Order) UnmarshalText(b []byte) error {
	newo, err := ParseOrder(b)
	if err != nil {
		return err
	}
	*o = newo
	return nil
}

// Scan implements the database/sql.Scanner interface for Order.
// It parses the string representation of the enum value from the database row.
// It returns an error if the row does not contain a valid enum value.
func (o *Order) Scan(value any) error {
	newo, err := ParseOrder(value)
	if err != nil {
		return err
	}
	*o = newo
	return nil
}

// Value implements the database/sql/driver.Valuer interface for Order.
// It returns the string representation of the enum value.
func (o Order) Value() (driver.Value, error) {
	return o.String(), nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for Order.
// It returns the binary representation of the enum value as a byte slice.
func (o Order) MarshalBinary() ([]byte, error) {
	return []byte("\"" + o.String() + "\""), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for Order.
// It parses the binary representation of the enum value from the byte slice.
// It returns an error if the byte slice does not contain a valid enum value.
func (o *Order) UnmarshalBinary(b []byte) error {
	newo, err := ParseOrder(b)
	if err != nil {
		return err
	}
	*o = newo
	return nil
}

// MarshalYAML implements the yaml.Marshaler interface for Order.
// It returns the string representation of the enum value.
// It returns an error if the enum value is invalid.
func (o Order) MarshalYAML() (any, error) {
	return o.String(), nil
}

// UnmarshalYAML implements the yaml.Unmarshaler interface for Order.
// It parses the string representation of the enum value from the YAML node.
// It returns an error if the YAML node does not contain a valid enum value.
func (o *Order) UnmarshalYAML(ctx context.Context, f func(any) error) error {
	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
	}
	return f(o.String())
}

// orderNames is a constant string slice containing all enum values cononical absolute names
const orderNames = "CREATEDAPPROVEDPROCESSINGREADY_TO_SHIPSHIPPEDDELIVEREDCANCELLEDPASSEDSKIPPEDSCHEDULEDRUNNINGBOOKED"

// orderNamesMap is a map of enum values to their canonical absolute
// name positions within the orderNames string slice
var orderNamesMap = map[Order]string{
	Orders.CREATED:     orderNames[0:7],
	Orders.APPROVED:    orderNames[7:15],
	Orders.PROCESSING:  orderNames[15:25],
	Orders.READYTOSHIP: orderNames[25:38],
	Orders.SHIPPED:     orderNames[38:45],
	Orders.DELIVERED:   orderNames[45:54],
	Orders.CANCELLED:   orderNames[54:63],
	Orders.PASSED:      orderNames[63:69],
	Orders.SKIPPED:     orderNames[69:76],
	Orders.SCHEDULED:   orderNames[76:85],
	Orders.RUNNING:     orderNames[85:92],
	Orders.BOOKED:      orderNames[92:98],
}

// String implements the Stringer interface.
// It returns the canonical absolute name of the enum value.
func (o Order) String() string {
	if str, ok := orderNamesMap[o]; ok {
		return str
	}
	return fmt.Sprintf("order(%d)", o.order)
}

// Compile-time check that all enum values are valid.
// This function is used to ensure that all enum values are defined and valid.
// It is called by the compiler to verify that the enum values are valid.
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [12]struct{}
	_ = x[created-0]
	_ = x[approved-1]
	_ = x[processing-2]
	_ = x[readyToShip-3]
	_ = x[shipped-4]
	_ = x[delivered-5]
	_ = x[cancelled-6]
	_ = x[passed-0]
	_ = x[skipped-1]
	_ = x[scheduled-2]
	_ = x[running-3]
	_ = x[booked-4]
}
