// DO NOT EDIT.
// code generated by goenums 'v0.3.8' at 2025-05-04 00:40:37.
// github.com/zarldev/goenums
//
// using the command:
//
// goenums multiple.go

package multipleenums

import (
	"bytes"
	"database/sql/driver"
	"fmt"
	"iter"
	"strconv"
)

type Order struct {
	order
}

type ordersContainer struct {
	CREATED     Order
	APPROVED    Order
	PROCESSING  Order
	READYTOSHIP Order
	SHIPPED     Order
	DELIVERED   Order
	CANCELLED   Order
}

var Orders = ordersContainer{
	CREATED: Order{
		order: created,
	},
	APPROVED: Order{
		order: approved,
	},
	PROCESSING: Order{
		order: processing,
	},
	READYTOSHIP: Order{
		order: readyToShip,
	},
	SHIPPED: Order{
		order: shipped,
	},
	DELIVERED: Order{
		order: delivered,
	},
	CANCELLED: Order{
		order: cancelled,
	},
}

// invalidOrder represents an invalid or undefined Order value.
// It is used as a default return value for failed parsing or conversion operations.
var invalidOrder = Order{}

// allSlice is an internal method that returns all valid Order values as a slice.
func (c ordersContainer) allSlice() []Order {
	return []Order{
		c.CREATED,
		c.APPROVED,
		c.PROCESSING,
		c.READYTOSHIP,
		c.SHIPPED,
		c.DELIVERED,
		c.CANCELLED,
	}
}

// AllSlice returns all valid Order values as a slice.
func (c ordersContainer) AllSlice() []Order {
	return c.allSlice()
}

// All returns all valid Order values.
// In Go 1.23+, this can be used with range-over-function iteration:
// ```
//
//	for v := range Orders.All() {
//	    // process each enum value
//	}
//
// ```
func (c ordersContainer) All() iter.Seq[Order] {
	return func(yield func(Order) bool) {
		for _, v := range c.allSlice() {
			if !yield(v) {
				return
			}
		}
	}
}

// ParseOrder converts various input types to a Order value.
// It accepts the following types:
// - Order: returns the value directly
// - string: parses the string representation
// - []byte: converts to string and parses
// - fmt.Stringer: uses the String() result for parsing
// - int/int32/int64: converts the integer to the corresponding enum value
//
// If the input cannot be converted to a valid Order value, it returns
// the invalidOrder value without an error.
func ParseOrder(a any) (Order, error) {
	res := invalidOrder
	switch v := a.(type) {
	case Order:
		return v, nil
	case []byte:
		res = stringToOrder(string(v))
	case string:
		res = stringToOrder(v)
	case fmt.Stringer:
		res = stringToOrder(v.String())
	case int:
		res = intToOrder(v)
	case int64:
		res = intToOrder(int(v))
	case int32:
		res = intToOrder(int(v))
	}
	return res, nil
}

// stringToOrder is an internal function that converts a string to a Order value.
// It uses a predefined mapping of string representations to enum values.
var (
	ordersNameMap = map[string]Order{
		"CREATED":       Orders.CREATED,     // primary alias
		"created":       Orders.CREATED,     // enum name
		"APPROVED":      Orders.APPROVED,    // primary alias
		"approved":      Orders.APPROVED,    // enum name
		"PROCESSING":    Orders.PROCESSING,  // primary alias
		"processing":    Orders.PROCESSING,  // enum name
		"READY_TO_SHIP": Orders.READYTOSHIP, // primary alias
		"readyToShip":   Orders.READYTOSHIP, // enum name
		"SHIPPED":       Orders.SHIPPED,     // primary alias
		"shipped":       Orders.SHIPPED,     // enum name
		"DELIVERED":     Orders.DELIVERED,   // primary alias
		"delivered":     Orders.DELIVERED,   // enum name
		"CANCELLED":     Orders.CANCELLED,   // primary alias
		"cancelled":     Orders.CANCELLED,   // enum name
	}
)

func stringToOrder(s string) Order {
	if v, ok := ordersNameMap[s]; ok {
		return v
	}
	return invalidOrder
}

// intToOrder converts an integer to a Order value.
// The integer is treated as the ordinal position in the enum sequence.
// The input is adjusted by -7 to account for the enum starting value.
// If the integer doesn't correspond to a valid enum value, invalidOrder is returned.
func intToOrder(i int) Order {
	i -= 7
	if i < 0 || i >= len(Orders.allSlice()) {
		return invalidOrder
	}
	return Orders.allSlice()[i]
}

// ExhaustiveOrders calls the provided function once for each valid Orders value.
// This is useful for switch statement exhaustiveness checking and for processing all enum values.
// Example usage:
// ```
//
//	ExhaustiveOrders(func(x Order) {
//	    switch x {
//	    case Orders.Cancelled:
//	        // handle Cancelled
//	    }
//	})
//
// ```
func ExhaustiveOrders(f func(Order)) {
	for _, p := range Orders.allSlice() {
		f(p)
	}
}

// validOrders is a map of valid Order values.
var validOrders = map[Order]bool{
	Orders.CREATED:     true,
	Orders.APPROVED:    true,
	Orders.PROCESSING:  true,
	Orders.READYTOSHIP: true,
	Orders.SHIPPED:     true,
	Orders.DELIVERED:   true,
	Orders.CANCELLED:   true,
}

// IsValid checks whether the Order value is valid.
// A valid value is one that is defined in the original enum and not marked as invalid.
func (p Order) IsValid() bool {
	return validOrders[p]
}

// MarshalJSON implements the json.Marshaler interface for Order.
// The enum value is encoded as its string representation.
func (p Order) MarshalJSON() ([]byte, error) {
	return []byte(`"` + p.String() + `"`), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface for Order.
// It supports unmarshaling from a string representation of the enum.
func (p *Order) UnmarshalJSON(b []byte) error {
	b = bytes.Trim(bytes.Trim(b, `"`), ` `)
	newp, err := ParseOrder(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// Scan implements the sql.Scanner interface for Order.
// This allows Order values to be scanned directly from database queries.
// It supports scanning from strings, []byte, or integers.
func (p *Order) Scan(value any) error {
	newp, err := ParseOrder(value)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// Value implements the driver.Valuer interface for Order.
// This allows Order values to be saved to databases.
// The value is stored as a string representation of the enum.
func (p Order) Value() (driver.Value, error) {
	return p.String(), nil
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for Order.
// It encodes the enum value as a byte slice.
func (p Order) MarshalBinary() ([]byte, error) {
	return []byte(p.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for Order.
// It decodes the enum value from a byte slice.
func (p *Order) UnmarshalBinary(b []byte) error {
	newp, err := ParseOrder(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for Order.
// The enum value is encoded as its string representation.
func (p Order) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Order.
// It supports unmarshaling from a string representation of the enum.
func (p *Order) UnmarshalText(b []byte) error {
	newp, err := ParseOrder(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [1]struct{}
	_ = x[created-0]
	_ = x[approved-1]
	_ = x[processing-2]
	_ = x[readyToShip-3]
	_ = x[shipped-4]
	_ = x[delivered-5]
	_ = x[cancelled-6]
}

const ordersName = "CREATEDAPPROVEDPROCESSINGREADY_TO_SHIPSHIPPEDDELIVEREDCANCELLED"

var ordersIdx = [...]uint16{0, 7, 15, 25, 38, 45, 54, 63}

// String returns the string representation of the Order value.
// For valid values, it returns the name of the constant.
// For invalid values, it returns a string in the format "orders(N)",
// where N is the numeric value.
func (i order) String() string {
	if i < 0 || i > order(len(ordersIdx)-1)+-1 {
		return "orders(" + (strconv.FormatInt(int64(i), 10) + ")")
	}
	return ordersName[ordersIdx[i]:ordersIdx[i+1]]
}
