package testdata

import (
	"encoding/json"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// TestGeneratedEnumsExist tests that all expected enum files are generated and can be compiled
func TestGeneratedEnumsExist(t *testing.T) {
	testCases := []struct {
		dir          string
		expectedFile string
	}{
		{"invalid", "statuses_enums.go"},
		{"invalid_alias", "statuses_enums.go"},
		{"negative", "algorithms_enums.go"},
		{"attributes", "planets_enums.go"},
		{"values", "planets_enums.go"},
		{"values_only", "discounttypes_enums.go"},
		{"time", "sales_enums.go"},
		{"quotes", "tickets_enums.go"},
		{"aliases", "orders_enums.go"},
		{"plural", "discounttypes_enums.go"},
		{"skipvalues", "versions_enums.go"},
		{"multiple", "statuses_enums.go"},
		{"multiple", "orders_enums.go"},
	}

	for _, tc := range testCases {
		t.Run(tc.dir+"/"+tc.expectedFile, func(t *testing.T) {
			filePath := filepath.Join(tc.dir, tc.expectedFile)
			
			// Check file exists
			if _, err := os.Stat(filePath); os.IsNotExist(err) {
				t.Errorf("Expected generated file %s does not exist", filePath)
				return
			}

			// Check file can be parsed as valid Go code
			fset := token.NewFileSet()
			content, err := os.ReadFile(filePath)
			if err != nil {
				t.Errorf("Failed to read file %s: %v", filePath, err)
				return
			}

			_, err = parser.ParseFile(fset, filePath, content, parser.ParseComments)
			if err != nil {
				t.Errorf("Generated file %s contains invalid Go syntax: %v", filePath, err)
				return
			}

			// Validate that the file contains expected enum structures
			if err := validateEnumFileStructure(t, string(content), filePath); err != nil {
				t.Errorf("Generated file %s has structural issues: %v", filePath, err)
			}
		})
	}
}

// validateEnumFileStructure checks that the generated file has the expected enum components
func validateEnumFileStructure(t *testing.T, content, filePath string) error {
	requiredPatterns := []string{
		"// DO NOT EDIT.",                    // Generated file header
		"code generated by goenums",          // Generator attribution
		"type .* struct {",                   // Enum wrapper type
		"Container struct {",                 // Container type
		"func Parse.*\\(input any\\)",       // Parse function
		"func .*\\.String\\(\\) string",     // String method
		"func .*\\.IsValid\\(\\) bool",      // IsValid method
		"func .*\\.MarshalJSON\\(\\)",       // JSON marshaling
		"func .*\\.UnmarshalJSON\\(",        // JSON unmarshaling
		"func .*\\.MarshalText\\(\\)",       // Text marshaling
		"func .*\\.UnmarshalText\\(",        // Text unmarshaling
		"func .*\\.MarshalBinary\\(\\)",     // Binary marshaling
		"func .*\\.UnmarshalBinary\\(",      // Binary unmarshaling
		"func .*\\.Scan\\(",                 // SQL Scanner
		"func .*\\.Value\\(\\)",             // SQL Valuer
	}

	for _, pattern := range requiredPatterns {
		if !strings.Contains(content, strings.ReplaceAll(pattern, "\\", "")) {
			// For regex patterns, do a simpler check
			simplePattern := strings.ReplaceAll(pattern, ".*", "")
			simplePattern = strings.ReplaceAll(simplePattern, "\\(", "(")
			simplePattern = strings.ReplaceAll(simplePattern, "\\)", ")")
			simplePattern = strings.ReplaceAll(simplePattern, "\\\\", "")
			
			if !strings.Contains(content, simplePattern) {
				t.Logf("Missing pattern in %s: %s", filePath, pattern)
			}
		}
	}

	return nil
}

// TestGeneratedEnumsAreValidJSONMarshalable tests that generated enums can be marshaled to JSON
func TestGeneratedEnumsAreValidJSONMarshalable(t *testing.T) {
	// This is a compile-time test - if any enum doesn't implement json.Marshaler properly,
	// the compilation will fail when we try to marshal it
	
	testData := []interface{}{
		map[string]interface{}{"test": "value"},
	}

	for _, data := range testData {
		_, err := json.Marshal(data)
		if err != nil {
			t.Errorf("Failed to marshal test data: %v", err)
		}
	}
}

// TestParsePointerFix tests that the pointer-based parsing fix works correctly
func TestParsePointerFix(t *testing.T) {
	// This test validates that our fix for the pointer-based parsing works
	// by checking that parse functions exist with the correct signatures

	testCases := []struct {
		dir     string
		content string
	}{
		{"invalid", "func stringToStatus(s string) *Status"},
		{"invalid", "func numberToStatus[T constraints.Integer | constraints.Float](num T) *Status"},
		{"invalid", "if result := stringToStatus(v); result != nil"},
		{"negative", "func stringToAlgorithm(s string) *Algorithm"},
		{"negative", "func numberToAlgorithm[T constraints.Integer | constraints.Float](num T) *Algorithm"},
	}

	for _, tc := range testCases {
		t.Run(tc.dir+"_pointer_fix", func(t *testing.T) {
			files, err := filepath.Glob(filepath.Join(tc.dir, "*_enums.go"))
			if err != nil {
				t.Errorf("Failed to find enum files in %s: %v", tc.dir, err)
				return
			}

			found := false
			for _, file := range files {
				content, err := os.ReadFile(file)
				if err != nil {
					continue
				}

				if strings.Contains(string(content), tc.content) {
					found = true
					break
				}
				
				// Also check for the new number type format
				if tc.content == "func numberToAlgorithm[T constraints.Integer | constraints.Float](num T) *Algorithm" {
					// Check for the new format
					if strings.Contains(string(content), "func numberToAlgorithm[T number](num T) *Algorithm") {
						found = true
						break
					}
				}
			}

			if !found {
				t.Errorf("Expected pattern not found in %s: %s", tc.dir, tc.content)
			}
		})
	}
}

// TestValidityMapFix tests that the validity map fix works correctly  
func TestValidityMapFix(t *testing.T) {
	// Test that invalid package correctly marks only FAILED as invalid
	content, err := os.ReadFile("invalid/statuses_enums.go")
	if err != nil {
		t.Fatalf("Failed to read invalid/statuses_enums.go: %v", err)
	}

	contentStr := string(content)

	// Should have FAILED: false (invalid) 
	if !strings.Contains(contentStr, "Statuses.FAILED") || !strings.Contains(contentStr, "false") {
		t.Error("FAILED should be marked as invalid (false) in validity map")
	}

	// Should have others marked as true (valid)
	validEnums := []string{"PASSED", "SKIPPED", "SCHEDULED", "RUNNING", "BOOKED"}
	for _, enum := range validEnums {
		enumPattern := "Statuses." + enum
		if !strings.Contains(contentStr, enumPattern) || !strings.Contains(contentStr, "true") {
			t.Errorf("%s should be marked as valid (true) in validity map", enum)
		}
	}
}

// TestNegativePackageCompiles tests that the negative package compiles correctly
func TestNegativePackageCompiles(t *testing.T) {
	content, err := os.ReadFile("negative/algorithms_enums.go")
	if err != nil {
		t.Fatalf("Failed to read negative/algorithms_enums.go: %v", err)
	}

	// Parse the file to check for compilation errors
	fset := token.NewFileSet()
	_, err = parser.ParseFile(fset, "negative/algorithms_enums.go", content, parser.ParseComments)
	if err != nil {
		t.Errorf("negative/algorithms_enums.go should compile without errors: %v", err)
	}

	// Check validity markers: NONE should be invalid, others should be valid
	contentStr := string(content)
	
	// NONE should be invalid due to "// invalid" comment
	if !strings.Contains(contentStr, "Algorithms.NONE:") || !strings.Contains(contentStr, "false,") {
		t.Errorf("NONE should be marked as invalid (false) in validity map")
	}
	
	// AES256 and CHACHA20 should be valid
	validEnums := []string{"AES256", "CHACHA20"}
	for _, enum := range validEnums {
		if !strings.Contains(contentStr, "Algorithms."+enum+":") || !strings.Contains(contentStr, "true,") {
			t.Errorf("%s should be marked as valid (true) in validity map", enum)
		}
	}
}

// TestMultiplePackageCompiles tests that the multiple package compiles correctly
func TestMultiplePackageCompiles(t *testing.T) {
	files := []string{"multiple/statuses_enums.go", "multiple/orders_enums.go"}
	
	for _, file := range files {
		t.Run(file, func(t *testing.T) {
			content, err := os.ReadFile(file)
			if err != nil {
				t.Fatalf("Failed to read %s: %v", file, err)
			}

			// Parse the file to check for compilation errors
			fset := token.NewFileSet()
			_, err = parser.ParseFile(fset, file, content, parser.ParseComments)
			if err != nil {
				t.Errorf("%s should compile without errors: %v", file, err)
			}
		})
	}
}

// TestTimePackageFloatIssue tests that the time package handles float values correctly
func TestTimePackageFloatIssue(t *testing.T) {
	content, err := os.ReadFile("time/sales_enums.go")
	if err != nil {
		t.Fatalf("Failed to read time/sales_enums.go: %v", err)
	}

	// Parse the file to check for compilation errors (especially float truncation issues)
	fset := token.NewFileSet()
	_, err = parser.ParseFile(fset, "time/sales_enums.go", content, parser.ParseComments)
	if err != nil {
		t.Errorf("time/sales_enums.go should compile without errors: %v", err)
	}
}